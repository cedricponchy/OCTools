/*	Example.h
 *
 *		This file was automatically generated by OCYacc, part of the OCTools
 *	suite available at:
 *
 *		https://github.com/w3woody/OCTools
 */

#ifndef Example_h
#define Example_h

#include <stdint.h>
#include <map>
#include <vector>
#include <string>

    %header


    %%


/*
 *	Yacc constants
 */

#define NUMBER                                        0x00110002

#ifndef OCLexInput_ValueDefined
#define OCLexInput_ValueDefined

/*  OCLexInputValue
 *
 *      Internally defined value.
 */

union OCLexInputValue {
    
    int value;
};

#endif

/*
 *	Predefined error codes
 */

// Indicates a warning; set if msg should not halt parsing or return error
#define ERRORMASK_WARNING		0x8000

#define ERROR_SYNTAX			0x0001
#define ERROR_MISSINGTOKEN		0x0002	// { @"token": string of token missing }
#define ERROR_MISSINGTOKENS		0x0003	// { @"tokens": array of token strings }
#define ERROR_STARTERRORID		0x0100	// Your errors should start with this

/*	OCLexInput
 *
 *		The protocol for our lex reader file that the lex stream must
 *	provide. This is the same as the protocol generated as part of the lex
 *	output, and allows us to glue the Lexer and Parser together.
 */

#ifndef OCLexInputProtocol
#define OCLexInputProtocol

class OCLexInput
{
	public:
		int32_t line;
		int32_t column;
		std::string filename;
		std::string text;
		std::string abort;

		virtual int32_t lex() = 0;
		union OCLexInputValue value;
};

#endif

/*
 *	Internal parser stack
 */

struct ExampleStack
{
	uint16_t state;
	int32_t line;
	int32_t column;
	std::string filename;
	union OCLexInputValue value;
};

/*	Example
 *
 *		The generated parser
 */

class Example
{
	public:
		Example(OCLexInput *lexer);
		virtual ~Example(void);

		virtual void error(int32_t line, int32_t col, std::string fname, int32_t errCode, std::map<std::string,std::string> &map);

		bool parse(void);


    %global

	private:
		std::vector<ExampleStack> stack;
		OCLexInput *lex;
		bool success;
		int32_t errorCount;

		ExampleStack processReduction(int16_t rule);
		int32_t actionForState(int32_t state, int32_t token);
		int32_t gotoForState(int32_t state, int32_t token);
		void errorWithCode(int32_t code, std::map<std::string,std::string> &data);
		void errorWithCode(int32_t code);
		void errorOK();
		std::string tokenToString(uint32_t token);
		bool reduceByAction(int16_t action);

    %local
};

#endif
