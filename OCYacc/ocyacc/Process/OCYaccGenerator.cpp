//
//  OCYaccGenerator.cpp
//  ocyacc
//
//  Created by William Woody on 8/13/17.
//  Copyright Â© 2017 Glenview Software. All rights reserved.
//

#include "OCYaccGenerator.h"

/************************************************************************/
/*																		*/
/*	Header Constants													*/
/*																		*/
/************************************************************************/

static const char *GHeader1 =
	"/*\t%s.h\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCYacc, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import <Foundation/Foundation.h>\n";

static const char *GHeader2 =
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tClass forwards\n"                                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@class %s;\n"                                                            \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tYacc constants\n"                                                    \
	" */\n"                                                                   \
	"\n";

static const char *GHeader3 =
	"\n"                                                                      \
	"/*\tOCLexInput\n"                                                        \
	" *\n"                                                                    \
	" *\t\tThe protocol for our lex reader file that the lex stream must\n"   \
	" *\tprovide. This is the same as the protocol generated as part of the lex\n" \
	" *\toutput, and allows us to glue the Lexer and Parser together.\n"      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCLexInputProtocol\n"                                            \
	"#define OCLexInputProtocol\n"                                            \
	"\n"                                                                      \
	"@protocol OCLexInput <NSObject>\n"                                       \
	"- (NSInteger)line;\n"                                                    \
	"- (NSInteger)column;\n"                                                  \
	"- (NSString *)filename;\n"                                               \
	"- (NSString *)text;\n"                                                   \
	"- (NSString *)abort;\n"                                                  \
	"\n"                                                                      \
	"- (NSInteger)lex;\n"                                                     \
	"\n"                                                                      \
	"- (id<NSObject>)value;\n"                                                \
	"@end\n"                                                                  \
	"\n"                                                                      \
	"#endif\n"                                                                \
	"\n"                                                                      \
	"/*\t%sError\n"                                                           \
	" *\n"                                                                    \
	" *\t\tThe protocol for our parser for handling errors. As errors take place,\n" \
	" *\twe invoke the method so the error can be recorded and displayed to the\n" \
	" *\tuser.\n"                                                             \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@protocol %sError <NSObject>\n"                                          \
	"- (void)errorFrom:(%s *)yacc line:(NSInteger)line column:(NSInteger)column\n" \
	"\t\tfilename:(NSString *)fname token:(NSString *)text\n"                 \
	"\t\terrorMessage:(NSString *)error;\n"                                   \
	"@end\n"                                                                  \
	"\n"                                                                      \
	"\n"                                                                      \
	"/*\t%s\n"                                                                \
	" *\n"                                                                    \
	" *\t\tThe generated parser\n"                                            \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@interface %s : NSObject\n"                                              \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tError processing\n"                                                  \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@property (weak) id<%sError> errorDelegate;\n"                           \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tExternal interfaces\n"                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (instancetype)initWithLexer:(id<OCLexInput>)lexer;\n"                  \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRun parser. If any errors are recorded during parsing, this returns\n" \
	" *\tNO.\n"                                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (BOOL)parse;\n"                                                        \
	"\n";

static const char *GHeader4 =
	"@end\n";

/************************************************************************/
/*																		*/
/*	Source Constants													*/
/*																		*/
/************************************************************************/

static const char *GSource1 =
	"/*\t%s.m\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCYacc, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import \"%s.h\"\n";

static const char *GSource2 =
	"/************************************************************************/\n" \
	"/*                                                                      */\n" \
	"/*  State Tables and Constants                                          */\n" \
	"/*                                                                      */\n" \
	"/************************************************************************/\n" \
	"\n";

/************************************************************************/
/*																		*/
/*	Construction/Destruction											*/
/*																		*/
/************************************************************************/

/*	OCYaccGenerator::OCYaccGenerator
 *
 *		Construt this class
 */

OCYaccGenerator::OCYaccGenerator(const OCYaccParser &p, const OCYaccLR1 &y) : parser(p), state(y)
{
}

/*	OCYaccGenerator::~OCYaccGenerator
 *
 *		Destructor
 */

OCYaccGenerator::~OCYaccGenerator()
{
}

/************************************************************************/
/*																		*/
/*	Write Files															*/
/*																		*/
/************************************************************************/

/*	OCYaccGenerator::WriteOCFile
 *
 *		Write the header
 */

void OCYaccGenerator::WriteOCFile(const char *classname, const char *outputName, FILE *f)
{
	size_t i,len;
	char buffer[64];

	// Prefix
	fprintf(f,GSource1,outputName,outputName);

	// Header declarations
	fprintf(f,"\n%s\n",parser.declCode.c_str());

	// Print states, declarations and constants
	fprintf(f,"%s",GSource2);

	// Constants to print
	fprintf(f,"// Various constants\n");
	fprintf(f,"#define K_ACCEPTSTATE       %-8zu     // Final accept state\n",state.accept);
	fprintf(f,"#define K_EOFTOKEN          0x%-8x   // EOF token ID\n",state.eofTokenID);
	fprintf(f,"#define K_ERRORTOKEN        0x%-8x   // Error token ID\n",state.errorTokenID);

	// Reduction table
	len = state.reductions.size();
	fprintf(f,"\n/*  ReductionTable\n *\n *      The number of tokens a reduce action removes from the stack\n */\n\n");
	fprintf(f,"static uint8_t ReductionTable[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%2zu",state.reductions[i].reduce);
	}
	fprintf(f,"\n};\n\n");

	// Action tables
	fprintf(f,"/*\n *  The following tables are compressed using CSR format.\n");
	fprintf(f," *  See https://en.wikipedia.org/wiki/Sparse_matrix\n");
	fprintf(f," */\n\n");

	fprintf(f,"/*  ActionI, J, A\n *\n *      Compressed action index table.\n */\n\n");
	len = state.actionI.size();
	fprintf(f,"static uint32_t ActionI[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%6zu",state.actionI[i]);
	}
	fprintf(f,"\n};\n\n");

	len = state.actionJ.size();
	fprintf(f,"static uint32_t ActionJ[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		uint32_t token = state.actionJ[i];
		if ((32 < token) && (token < 127) && (token != '\'') && (token != '\\')) {
			sprintf(buffer,"'%c'",(char)token);
		} else {
			sprintf(buffer,"0x%x",token);
		}
		fprintf(f,"%8s",buffer);
	}
	fprintf(f,"\n};\n\n");

	len = state.actionA.size();
	fprintf(f,"// Note: negative == reduce (1+rule), positive == shift (state).\n");
	fprintf(f,"static int16_t ActionA[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		int32_t val = (int32_t)(state.actionA[i].value);
		if (state.actionA[i].reduce) val = -val-1;

		fprintf(f,"%6d",val);
	}
	fprintf(f,"\n};\n\n");

	// Goto table
	fprintf(f,"/*  GotoI, J, A\n *\n *      Compressed goto table.\n */\n\n");
	len = state.actionI.size();
	fprintf(f,"static uint32_t GotoI[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%6zu",state.gotoI[i]);
	}
	fprintf(f,"\n};\n\n");

	len = state.gotoJ.size();
	fprintf(f,"static uint32_t GotoJ[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		sprintf(buffer,"0x%x",state.gotoJ[i]);
		fprintf(f,"%8s",buffer);
	}
	fprintf(f,"\n};\n\n");

	len = state.gotoA.size();
	fprintf(f,"static int16_t GotoA[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		int32_t val = (int32_t)(state.gotoA[i]);

		fprintf(f,"%6d",val);
	}
	fprintf(f,"\n};\n\n");

}

/*	OCYaccGenerator::WriteOCHeader
 *
 *		Write the header
 */

void OCYaccGenerator::WriteOCHeader(const char *classname, const char *outputName, FILE *f)
{
	// Prefix
	fprintf(f,GHeader1,outputName);

	// Header declarations
	fprintf(f,"\n%s\n",parser.classHeader.c_str());

	// Forwards
	fprintf(f,GHeader2,classname);

	// Yacc constants
	std::vector<OCYaccLR1::TokenConstant>::const_iterator tokIter;
	for (tokIter = state.tokens.cbegin(); tokIter != state.tokens.cend(); ++tokIter) {
		fprintf(f,"#define %-45s 0x%08x",tokIter->token.c_str(),tokIter->value);
		if (!tokIter->used) {
			fprintf(f,"   /* Unused */\n");
		} else {
			fprintf(f,"\n");
		}
	}

	// Bulk of declarations
	fprintf(f,GHeader3,classname,classname,classname,classname,classname,classname);

	// Class globals
	fprintf(f,"\n%s\n",parser.classGlobal.c_str());

	// Final
	fprintf(f,"%s\n",GHeader4);
}
