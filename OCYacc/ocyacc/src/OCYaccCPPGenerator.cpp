//
//  OCYaccCPPGenerator.cpp
//  ocyacc
//
//  Created by William Woody on 4/12/18.
//  Copyright Â© 2018 Glenview Software. All rights reserved.
//

#include "OCYaccCPPGenerator.h"

/************************************************************************/
/*																		*/
/*	Header Constants													*/
/*																		*/
/************************************************************************/

// 3
static const char *GHeader1 =
	"/*\t%s.h\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCYacc, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef %s_h\n"                                                          \
	"#define %s_h\n"                                                          \
	"\n"                                                                      \
	"#include <stdint.h>\n"                                                   \
	"#include <map>\n"                                                        \
	"#include <vector>\n"                                                     \
	"#include <string>\n";

// 0
static const char *GHeader2 =
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tYacc constants\n"                                                    \
	" */\n"                                                                   \
	"\n";

// 0
static const char *GHeader3 =
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tPredefined error codes\n"                                            \
	" */\n"                                                                   \
	"\n"                                                                      \
	"// Indicates a warning; set if msg should not halt parsing or return error\n" \
	"#define ERRORMASK_WARNING\t\t0x8000\n"                                   \
	"\n"                                                                      \
	"#define ERROR_SYNTAX\t\t\t0x0001\n"                                      \
	"#define ERROR_MISSINGTOKEN\t\t0x0002\t// { @\"token\": string of token missing }\n" \
	"#define ERROR_MISSINGTOKENS\t\t0x0003\t// { @\"tokens\": array of token strings }\n" \
	"#define ERROR_STARTERRORID\t\t0x0100\t// Your errors should start with this\n" \
	"\n";

// 4
static const char *GHeader3a =
	"/*\t%sInput\n"                                                        	  \
	" *\n"                                                                    \
	" *\t\tThe protocol for our lex reader file that the lex stream must\n"   \
	" *\tprovide. This is the same as the protocol generated as part of the lex\n" \
	" *\toutput, and allows us to glue the Lexer and Parser together.\n"      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef %sInputProtocol\n"                                            	  \
	"#define %sInputProtocol\n"                                            	  \
	"\n"                                                                      \
	"class %sInput\n"                                                      	  \
	"{\n"                                                                     \
	"\tpublic:\n"                                                             \
	"\t\tint32_t line;\n"                                                     \
	"\t\tint32_t column;\n"                                                   \
	"\t\tstd::string filename;\n"                                             \
	"\t\tstd::string text;\n"                                                 \
	"\t\tstd::string abort;\n"                                                \
	"\n"                                                                      \
	"\t\tvirtual int32_t lex() = 0;\n";

static const char *GHeader3a1 =
	"};\n"                                                                    \
	"\n"                                                                      \
	"#endif\n";

// 1, class
static const char *GHeader3b =
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal parser stack\n"                                             \
	" */\n"                                                                   \
	"\n"                                                                      \
	"struct %sStack\n"                                                        \
	"{\n"                                                                     \
	"\tuint16_t state;\n"                                                     \
	"\tint32_t line;\n"                                                       \
	"\tint32_t column;\n"                                                     \
	"\tstd::string filename;\n";

// 5, class, class, class, lex, class
static const char *GHeader3c =
	"};\n"                                                                    \
	"\n"                                                                      \
	"/*\t%s\n"                                                                \
	" *\n"                                                                    \
	" *\t\tThe generated parser\n"                                            \
	" */\n"                                                                   \
	"\n"                                                                      \
	"class %s\n"                                                              \
	"{\n"                                                                     \
	"\tpublic:\n"                                                             \
	"\t\t%s(%s *lexer);\n"                                                    \
	"\t\tvirtual ~%s(void);\n"                                                \
	"\n"                                                                      \
	"\t\tvirtual void error(int32_t line, int32_t col, std::string fname, int32_t errCode, std::map<std::string,std::string> &map);\n" \
	"\n"                                                                      \
	"\t\tbool parse(void);\n";

// 3, class, lex, class
static const char *GHeader4 =
	"\tprivate:\n"                                                            \
	"\t\tstd::vector<%sStack> stack;\n"                                       \
	"\t\t%s *lex;\n"                                                          \
	"\t\tbool success;\n"                                                     \
	"\t\tint32_t errorCount;\n"                                               \
	"\n"                                                                      \
	"\t\tbool hasError;\n"                                                    \
	"\t\tint32_t errorLine;\n"                                                \
	"\t\tint32_t errorColumn;\n"                                              \
	"\t\tstd::string errorFileName;\n"										  \
	"\n"                                                                      \
	"\t\t%sStack processReduction(int16_t rule);\n"                           \
	"\t\tint32_t actionForState(int32_t state, int32_t token);\n"             \
	"\t\tint32_t gotoForState(int32_t state, int32_t token);\n"               \
	"\t\tvoid errorWithCode(int32_t code, std::map<std::string,std::string> &data);\n" \
	"\t\tvoid errorWithCode(int32_t code);\n"                                 \
	"\t\tvoid errorOK();\n"                                                   \
	"\t\tstd::string tokenToString(uint32_t token);\n"                        \
	"\t\tbool reduceByAction(int16_t action);\n";

static const char *GHeader5 =
	"};\n"                                                                    \
	"\n"                                                                      \
	"#endif\n";

/************************************************************************/
/*																		*/
/*	Source Constants													*/
/*																		*/
/************************************************************************/

static const char *GSource1 =		// 2
	"/*\t%s.cpp\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCYacc, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#include \"%s.h\"\n";

static const char *GSource2 =		// 0
	"/*\n"                                                                    \
	" *\tNote: this is a baseline implementation for an LR parser as described in\n" \
	" *\tAho, Sethi, Ullman: \"Compilers: Principles, Techniques and Tools\", (the\n" \
	" *\tDragon Book), pages 216-220. Unlike the example there we don\'t bother \n" \
	" *\tstoring the tokens on the token stack. We also take some liberties to\n" \
	" *\tcompress our tables, and do a few optimizations similar to Bison.\n" \
	" *\n"                                                                    \
	" *\tTable compression scheme comes from\n"                               \
	" *\n"                                                                    \
	" *\thttps://en.wikipedia.org/wiki/Sparse_matrix\n"                       \
	" *\n"                                                                    \
	" *\tA discussion of the Bison internals comes from\n"                    \
	" *\n"                                                                    \
	" *\thttps://www.cs.uic.edu/~spopuri/cparser.html\n"                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"/************************************************************************/\n" \
	"/*                                                                      */\n" \
	"/*  State Tables and Constants                                          */\n" \
	"/*                                                                      */\n" \
	"/************************************************************************/\n"
	"\n";

static const char *GSource3 = // 3 class class lex
	"/************************************************************************/\n" \
	"/*                                                                      */\n" \
	"/*  Parser Code\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n"                       \
	"/*                                                                      */\n" \
	"/************************************************************************/\n" \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tConstruction\n"                                                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"%s::%s(%s *l)\n"                                                         \
	"{\n"                                                                     \
	"\tlex = l;\n";

static const char *GSource4 = // 2
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tDestruction\n"                                                       \
	" */\n"                                                                   \
	"\n"                                                                      \
	"%s::~%s()\n"                                                             \
	"{\n";

static const char *GSource5 = // 0
	"}\n"                                                                     \
	"\n";

static const char *GSource6 = // 4
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tProcess production rule. This processes the production rule and creates\n" \
	" *\ta new stack state with the rule reduction.\n"                        \
	" */\n"                                                                   \
	"\n"                                                                      \
	"%sStack %s::processReduction(int16_t rule)\n"                            \
	"{\n"                                                                     \
	"\t// Get production len, for translating $1...$N into something useful\n" \
	"\tint32_t pos = (int32_t)stack.size() - RuleLength[rule];\n"             \
	"\n"                                                                      \
	"\t// Set up initial state.\n"                                            \
	"\t%sStack s;\n"                                                          \
	"\n"                                                                      \
	"\t// File position of reduced rule is first token of the symbols reduced\n" \
	"\t%sStack &fs = stack[pos];\n"                                           \
	"\ts.filename = fs.filename;\n"                                           \
	"\ts.line = fs.line;\n"                                                   \
	"\ts.column = fs.column;\n"                                               \
	"\n"                                                                      \
	"\t// Now process production.\n"                                          \
	"\t//\n"                                                                  \
	"\t// Note that $$ translated into (s.value), and\n"                      \
	"\t// $n translates into ((<type> *)(stack[pos+(n-1)])), where <type>\n" \
	"\t// is the declared type of the token or production rule.\n"            \
	"\n"                                                                      \
	"\ttry {\n"                                                               \
	"\t\tswitch (rule) {\n";

static const char *GSource7 = // 16
	"\t\t\tdefault:\n"                                                        \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"\tcatch (...) {\n"                                                       \
	"\t}\n"                                                                   \
	"\treturn s;\n"                                                           \
	"}\n"                                                                     \
	"/*\n"                                                                    \
	" *\tLook up the action value for the state and token values provided. This\n" \
	" *\tparses through the ActionI, ActionJ and ActionA lists to find the correct\n" \
	" *\tentry. This returns NSIntegerMax if a value was not found, and this is an\n" \
	" *\terror entry.\n"                                                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"int32_t %s::actionForState(int32_t state, int32_t token)\n"              \
	"{\n"                                                                     \
	"\tsize_t min,max,mid;\n"                                                 \
	"\n"                                                                      \
	"\t/* Deal with EOF case */\n"                                            \
	"\tif (token == -1) token = K_EOFTOKEN;\n"                                \
	"\n"                                                                      \
	"\t/* Find range */\n"                                                    \
	"\tmin = ActionI[state];\n"                                               \
	"\tmax = ActionI[state+1];\n"                                             \
	"\n"                                                                      \
	"\t/* Binary search for value in ja */\n"                                 \
	"\twhile (min < max) {\n"                                                 \
	"\t\tmid = (min + max)/2;\n"                                              \
	"\t\tuint32_t j = ActionJ[mid];\n"                                        \
	"\t\tif (token == j) {\n"                                                 \
	"\t\t\treturn ActionA[mid];\n"                                            \
	"\t\t} else if (token < j) {\n"                                           \
	"\t\t\tmax = mid;\n"                                                      \
	"\t\t} else {\n"                                                          \
	"\t\t\tmin = mid+1;\n"                                                    \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"\treturn INT_MAX;\n"                                                     \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tLook up the goto value for the state and token (production rule) provided.\n" \
	" *\tOperates the same as actionForState, except we look in the goto table.\n" \
	" *\tIn teory I guess we could combine these two tables (as productions and\n" \
	" *\ttokens do not overlap).\n"                                           \
	" */\n"                                                                   \
	"\n"                                                                      \
	"int32_t %s::gotoForState(int32_t state, int32_t token)\n"                \
	"{\n"                                                                     \
	"\tsize_t min,max,mid;\n"                                                 \
	"\n"                                                                      \
	"\t/* Find range */\n"                                                    \
	"\tmin = GotoI[state];\n"                                                 \
	"\tmax = GotoI[state+1];\n"                                               \
	"\n"                                                                      \
	"\t/* Binary search for value in ja */\n"                                 \
	"\twhile (min < max) {\n"                                                 \
	"\t\tmid = (min + max)/2;\n"                                              \
	"\t\tint32_t j = GotoJ[mid];\n"                                           \
	"\t\tif (token == j) {\n"                                                 \
	"\t\t\treturn GotoA[mid];\n"                                              \
	"\t\t} else if (token < j) {\n"                                           \
	"\t\t\tmax = mid;\n"                                                      \
	"\t\t} else {\n"                                                          \
	"\t\t\tmin = mid+1;\n"                                                    \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"\treturn INT_MAX;\n"                                                     \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\t%s::error\n"                                                         \
	" *\n"                                                                    \
	" *\t\tOverride this if you want error reporting\n"                       \
	" */\n"                                                                   \
	"\n"                                                                      \
	"void %s::error(int32_t line, int32_t col, std::string fname, int32_t errCode, std::map<std::string,std::string> &map)\n" \
	"{\n"                                                                     \
	"\t// By default this does nothing.\n"                                    \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tErrors. This formats and prints the specified error\n"               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"void %s::errorWithCode(int32_t code, std::map<std::string,std::string> &data)\n" \
	"{\n"                                                                     \
	"\tif (errorCount > 0) return;\t\t// skip until synced on 3 shifts\n"     \
	"\n"                                                                      \
	"\t// Call delegate with current token position\n"                        \
	"\t// Token position is the topmost symbol\n"                             \
	"\tif (hasError) {\n"                                                     \
	"\t\terror(errorLine,errorColumn,errorFileName,code,data);\n"             \
	"\t} else {\n"                                                            \
	"\t\t%sStack &top = stack.back();\n"                                      \
	"\t\terror(top.line,top.column,top.filename,code,data);\n"                \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t// And now skip the next 3 token shifts so we don\'t spew garbage.\n"  \
	"\tif (0 == (code & ERRORMASK_WARNING)) {\n"                              \
	"\t\tsuccess = false;\n"                                                  \
	"\t\terrorCount = 3;\n"                                                   \
	"\t}\n"                                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"void %s::errorWithCode(int32_t code)\n"                                  \
	"{\n"                                                                     \
	"\tstd::map<std::string,std::string> empty;\n"                            \
	"\terrorWithCode(code, empty);\n"                                         \
	"}\n"                                                                     \
	"\n"                                                                      \
	"void %s::errorOK()\n"                                                    \
	"{\n"                                                                     \
	"\terrorCount = 0;\n"                                                     \
	"}\n"                                                                     \
	"\n"                                                                      \
	"std::string %s::tokenToString(uint32_t token)\n"                         \
	"{\n"                                                                     \
	"\tif (token >= K_FIRSTTOKEN) {\n"                                        \
	"\t\treturn TokenArray[token - K_FIRSTTOKEN];\n"                          \
	"\t} else {\n"                                                            \
	"\t\t/*\n"                                                                \
	"\t\t *\tConvert token to UTF-8\n"                                        \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tstd::string ret;\n"                                                  \
	"\t\tif (token < 0x80) {\n"                                               \
	"\t\t\tret += (char)token;\n"                                             \
	"\t\t} else if (token < 0x800) {\n"                                       \
	"\t\t\tret += (char)(0xC0 | (0x1F & (token >> 6)));\n"                    \
	"\t\t\tret += (char)(0x80 | (0x3F & (token)));\n"                         \
	"\t\t} else if (token < 0x10000) {\n"                                     \
	"\t\t\tret += (char)(0xE0 | (0x0F & (token >> 12)));\n"                   \
	"\t\t\tret += (char)(0x80 | (0x3F & (token >> 6)));\n"                    \
	"\t\t\tret += (char)(0x80 | (0x3F & (token)));\n"                         \
	"\t\t} else {\n"                                                          \
	"\t\t\tret += (char)(0xF0 | (0x07 & (token >> 18)));\n"                   \
	"\t\t\tret += (char)(0x80 | (0x3F & (token >> 12)));\n"                   \
	"\t\t\tret += (char)(0x80 | (0x3F & (token >> 6)));\n"                    \
	"\t\t\tret += (char)(0x80 | (0x3F & (token)));\n"                         \
	"\t\t}\n"                                                                 \
	"\t\treturn ret;\n"                                                       \
	"\t}\n"                                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"bool %s::reduceByAction(int16_t action)\n"                               \
	"{\n"                                                                     \
	"\t// Determine the new state we\'re transitioning to.\n"                 \
	"\tuint32_t production = RuleProduction[action];\n"                       \
	"\tuint8_t length = RuleLength[action];\n"                                \
	"\n"                                                                      \
	"\t// We pull the state we\'d have after popping the stack.\n"            \
	"\tuint16_t statep = stack[stack.size() - length - 1].state;\n"           \
	"\n"                                                                      \
	"\t// Now calculate the state we should transition to\n"                  \
	"\tint32_t newState = gotoForState(statep,production);\n"                 \
	"\tif (newState == INT_MAX) return false;\n"                              \
	"\n"                                                                      \
	"\t// Process production rule, which generates the new state\n"           \
	"\t%sStack state = processReduction(action);\n"                           \
	"\n"                                                                      \
	"\t// Update state\n"                                                     \
	"\tstate.state = newState;\n"                                             \
	"\n"                                                                      \
	"\t// Pop the stack\n"                                                    \
	"\tstack.erase(stack.begin() + (stack.size() - length),stack.end());\n"   \
	"\n"                                                                      \
	"\t// Push new state\n"                                                   \
	"\tstack.push_back(state);\n"                                             \
	"\n"                                                                      \
	"\t// Clear the error marker\n"											  \
	"\thasError = false;\n"													  \
	"\n"                                                                      \
	"\t// Done.\n"                                                            \
	"\treturn true;\n"                                                        \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tParser engine. Returns NO if there was an error during processing. Note\n" \
	" *\tthat as we uncover errors we call our delegate for error handling. This\n" \
	" *\timplements the algorithm described in the Dragon Book, Algorithm 4.7.\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"bool %s::parse()\n"                                                      \
	"{\n"                                                                     \
	"\tint32_t a;\t\t\t\t// lex symbol\n"                                     \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tStep 1: reset and push the empty state.\n"                         \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tsuccess = true;\n"                                                     \
	"\tstack.clear();\n"                                                      \
	"\n"                                                                      \
	"\terrorCount = 0;\n"													  \
	"\thasError = false;\n"													  \
	"\n"                                                                      \
	"\t%sStack initStack;\n"                                                  \
	"\tinitStack.state = K_STARTSTATE;\n"                                     \
	"\tinitStack.filename = lex->filename;\n"                                 \
	"\tinitStack.line = lex->line;\n"                                         \
	"\tinitStack.column = lex->column;\n"                                     \
	"\tstack.push_back(initStack);\n"                                         \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tNow repeat forever:\n"                                             \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\ta = lex->lex();\n"                                                     \
	"\n"                                                                      \
	"\tfor (;;) {\n"                                                          \
	"\t\t%sStack &s = stack.back();\n"                                        \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tDetermine if this is the end state. If so, then we immediately\n" \
	"\t\t *\tquit. We assume the user has set the production rule at the\n"   \
	"\t\t *\ttop, so we can simply drop the stack\n"                          \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tif (s.state == K_ACCEPTSTATE) {\n"                                   \
	"\t\t\tstack.clear();\n"                                                  \
	"\t\t\treturn success;\n"                                                 \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tNow determine the action and shift, reduce or handle error as\n" \
	"\t\t *\tappropriate\n"                                                   \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tint32_t action = actionForState(s.state, a);\n"                      \
	"\n"                                                                      \
	"\t\tbool foundError = false;\n"										  \
	"\t\tif (action == INT_MAX) {\n"                                          \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tHandle error. First, note we have an error, and note the\n"    \
	"\t\t\t *\tsymbol on which our error took place.\n"                       \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tsuccess = false;\t\t// regardless, we will always fail.\n"         \
	"\t\t\terrorFileName = lex->filename;\n"                                  \
	"\t\t\terrorLine = lex->line;\n"                                          \
	"\t\t\terrorColumn = lex->column;\n"                                      \
	"\t\t\thasError = true;\n"                                                \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tFirst, scan backwards from the current state, looking for one\n" \
	"\t\t\t *\twhich has an \'error\' symbol.\n"                              \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tsize_t ix = stack.size();\n"                                       \
	"\t\t\twhile ((ix > 0) && !foundError) {\n"                               \
	"\t\t\t\t%sStack &si = stack[--ix];\n"                                    \
	"\t\t\t\taction = actionForState(si.state, K_ERRORTOKEN);\n"              \
	"\t\t\t\tif ((action >= 0) && (action != INT_MAX)) {\n"                   \
	"\t\t\t\t\t/*\n"                                                          \
	"\t\t\t\t\t *\tEncountered error state. If the user has defined an\n"     \
	"\t\t\t\t\t *\terror token, we ultimately will want to (a) unwind\n"      \
	"\t\t\t\t\t *\tthe stack until we find a state which handles the\n"       \
	"\t\t\t\t\t *\terror transition. We then .\n"                             \
	"\t\t\t\t\t */\n"                                                         \
	"\n"                                                                      \
	"\t\t\t\t\tif (ix+1 < stack.size()) {\n"                                  \
	"\t\t\t\t\t\tstack.erase(stack.begin() + (ix + 1),stack.end());\n"        \
	"\t\t\t\t\t}\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\t\t/*\n"                                                          \
	"\t\t\t\t\t *\tAt this point we perform a shift to our new error\n"       \
	"\t\t\t\t\t *\tstate.\n"                                                  \
	"\t\t\t\t\t */\n"                                                         \
	"\n"                                                                      \
	"\t\t\t\t\t%sStack stmp;\n"                                               \
	"\t\t\t\t\tstmp.state = action;\n";

static const char *GSource8 = // 10
	"\t\t\t\t\tstmp.filename = lex->filename;\n"                              \
	"\t\t\t\t\tstmp.line = lex->line;\n"                                      \
	"\t\t\t\t\tstmp.column = lex->column;\n"                                  \
	"\t\t\t\t\tstack.push_back(stmp);\n"                                      \
	"\n"                                                                      \
	"\t\t\t\t\t/*\n"                                                          \
	"\t\t\t\t\t *\tSecond, we start pulling symbols until we find a symbol\n" \
	"\t\t\t\t\t *\tthat shifts, or until we hit the end of file symbol.\n"    \
	"\t\t\t\t\t *\tThis becomes our current token for parsing\n"              \
	"\t\t\t\t\t */\n"                                                         \
	"\n"                                                                      \
	"\t\t\t\t\tfor (;;) {\n"                                                  \
	"\t\t\t\t\t\ta = lex->lex();\n"                                           \
	"\t\t\t\t\t\taction = actionForState(s.state, a);\n"                      \
	"\t\t\t\t\t\tif ((action >= 0) && (action != INT_MAX)) {\n"               \
	"\t\t\t\t\t\t\t/*\n"                                                      \
	"\t\t\t\t\t\t\t *\tValid shift. This becomes our current token,\n"        \
	"\t\t\t\t\t\t\t *\tand we resume processing.\n"                           \
	"\t\t\t\t\t\t\t */\n"                                                     \
	"\n"                                                                      \
	"\t\t\t\t\t\t\tfoundError = true;\n"                                      \
	"\t\t\t\t\t\t\tbreak;\n"                                                  \
	"\n"                                                                      \
	"\t\t\t\t\t\t} else if ((a == K_EOFTOKEN) || (a == -1)) {\n"              \
	"\t\t\t\t\t\t\t/*\n"                                                      \
	"\t\t\t\t\t\t\t *\tWe ran out of tokens. At this point all\n"             \
	"\t\t\t\t\t\t\t *\twe can do is print an error and force quit.\n"         \
	"\t\t\t\t\t\t\t */\n"                                                     \
	"\n"                                                                      \
	"\t\t\t\t\t\t\terrorWithCode(ERROR_SYNTAX);\n"                            \
	"\t\t\t\t\t\t\tstack.clear();\n"                                          \
	"\n"                                                                      \
	"\t\t\t\t\t\t\treturn false;\n"                                           \
	"\t\t\t\t\t\t}\n"                                                         \
	"\t\t\t\t\t}\n"                                                           \
	"\t\t\t\t}\n"                                                             \
	"\t\t\t}\n"                                                               \
	"\t\t\tif (foundError) continue;\n"										  \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tIf we reach this point, there is no error we can recover to.\n" \
	"\t\t\t *\tSo figure this out on our own.\n"                              \
	"\t\t\t *\n"                                                              \
	"\t\t\t *\tFirst, we see if the state we\'re in has a limited number of\n" \
	"\t\t\t *\tchoices. For example, in C, the \'for\' keyword will always be\n" \
	"\t\t\t *\tfollowed by a \'(\' token, so we can offer to automatically\n" \
	"\t\t\t *\tinsert that token.\n"                                          \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tint32_t actionMin = ActionI[s.state];\n"                           \
	"\t\t\tint32_t actionMax = ActionI[s.state + 1];\n"                       \
	"\t\t\tint32_t actionVal = actionMin;\n"                                  \
	"\t\t\tint16_t actionState = -1;\n"                                       \
	"\t\t\tfor (int32_t ix = actionMin; ix < actionMax; ++ix) {\n"            \
	"\t\t\t\tint16_t act = ActionA[ix];\n"                                    \
	"\t\t\t\tif (actionState == -1) {\n"                                      \
	"\t\t\t\t\tif (act >= 0) {\n"                                             \
	"\t\t\t\t\t\tactionState = act;\n"                                        \
	"\t\t\t\t\t\tactionVal = ix;\n"                                           \
	"\t\t\t\t\t}\n"                                                           \
	"\t\t\t\t} else {\n"                                                      \
	"\t\t\t\t\tactionState = -1;\n"                                           \
	"\t\t\t\t\tbreak;\n"                                                      \
	"\t\t\t\t}\n"                                                             \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\tif (actionState != -1) {\n"                                        \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tWe can accomplish this transition with one token. Print\n"   \
	"\t\t\t\t *\tan error, and do a shift on the state with an empty value.\n" \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\tstd::string tokenStr = tokenToString(ActionJ[actionVal]);\n"     \
	"\t\t\t\tstd::map<std::string,std::string> map;\n"                        \
	"\t\t\t\tmap[\"token\"] = tokenStr;\n"                                    \
	"\t\t\t\terrorWithCode(ERROR_MISSINGTOKEN, map);\n"                       \
	"\n"                                                                      \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tPerform a shift but do not pull a new token\n"               \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\t%sStack &top = stack.back();\n"                                  \
	"\n"                                                                      \
	"\t\t\t\t%sStack stmp;\n"                                                 \
	"\t\t\t\tstmp.state = actionState;\n";

static const char *GSource9 = // 1
	"\t\t\t\tstmp.filename = top.filename;\n"                                 \
	"\t\t\t\tstmp.line = top.line;\n"                                         \
	"\t\t\t\tstmp.column = top.column;\n"                                     \
	"\n"                                                                      \
	"\t\t\t\tstack.push_back(stmp);\n"                                        \
	"\t\t\t\tcontinue;\n"                                                     \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tSee if we have a limited choice in reductions. If this can\n"  \
	"\t\t\t *\tonly reduce to a single state, try that reduction.\n"          \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tactionState = 0;\n"                                                \
	"\t\t\tfor (int32_t ix = actionMin; ix < actionMax; ++ix) {\n"            \
	"\t\t\t\tint16_t act = ActionA[ix];\n"                                    \
	"\t\t\t\tif (actionState == 0) {\n"                                       \
	"\t\t\t\t\tif ((act < 0) && (actionState != act)) {\n"                    \
	"\t\t\t\t\t\tactionState = act;\n"                                        \
	"\t\t\t\t\t}\n"                                                           \
	"\t\t\t\t} else {\n"                                                      \
	"\t\t\t\t\tactionState = 0;\n"                                            \
	"\t\t\t\t\tbreak;\n"                                                      \
	"\t\t\t\t}\n"                                                             \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\tif (actionState != 0) {\n"                                         \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tWe have one possible reduction. Try that. Note that this\n"  \
	"\t\t\t\t *\twill trigger a syntax error since we\'re reducing down\n"    \
	"\t\t\t\t *\twithout the follow token. My hope is that the state we\n"    \
	"\t\t\t\t *\ttransition to has a limited set of next tokens to follow.\n" \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\treduceByAction(action);\n"                                       \
	"\t\t\t\tcontinue;\n"                                                     \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tIf we have a limited number of tokens which can follow,\n"     \
	"\t\t\t *\tprint a list of them. Then shift by the first one we\n"        \
	"\t\t\t *\tfind. We don\'t do this if the number of shifts is greater\n"  \
	"\t\t\t *\tthan five.\n"                                                  \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tif (actionMax - actionMin <= 5) {\n"                               \
	"\t\t\t\tstd::string tlist;\n"                                            \
	"\t\t\t\tfor (int32_t ix = actionMin; ix < actionMax; ++ix) {\n"          \
	"\t\t\t\t\tif (ix > actionMin) tlist += \", \";\n"                        \
	"\t\t\t\t\ttlist += tokenToString(ActionJ[ix]);\n"                        \
	"\t\t\t\t}\n"                                                             \
	"\n"                                                                      \
	"\t\t\t\tstd::map<std::string,std::string> map;\n"                        \
	"\t\t\t\tmap[\"token\"] = tlist;\n"                                       \
	"\t\t\t\terrorWithCode(ERROR_MISSINGTOKENS, map);\n"                      \
	"\n"                                                                      \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tNow we artificially insert the first of the list of\n"       \
	"\t\t\t\t *\ttokens as our action and continue.\n"                        \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\ta = ActionJ[actionMin];\n"                                       \
	"\t\t\t\tcontinue;\n"                                                     \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tIf we get here, things just went too far south. So we\n"       \
	"\t\t\t *\tskip a token, print syntax error and move on\n"                \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\terrorWithCode(ERROR_SYNTAX);\n"                                    \
	"\t\t\ta = lex->lex();\n"                                                 \
	"\t\t\tif (a == -1) return false;\n"                                      \
	"\n"                                                                      \
	"\t\t} else if (action >= 0) {\n"                                         \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tShift operation.\n"                                            \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\t// Shift\n"                                                        \
	"\t\t\t%sStack stmp;\n"                                                   \
	"\t\t\tstmp.state = action;\n";


static const char *GSource10 = // 0
	"\t\t\tstmp.filename = lex->filename;\n"                                  \
	"\t\t\tstmp.line = lex->line;\n"                                          \
	"\t\t\tstmp.column = lex->column;\n"                                      \
	"\n"                                                                      \
	"\t\t\tstack.push_back(stmp);\n"                                          \
	"\n"                                                                      \
	"\t\t\t// Advance to next token.\n"                                       \
	"\t\t\ta = lex->lex();\n"                                                 \
	"\n"                                                                      \
	"\t\t\t// Decrement our error count. If this is non-zero we\'re in an\n"  \
	"\t\t\t// error state, and we don\'t pass spurrous errors upwards\n"      \
	"\t\t\tif (errorCount) --errorCount;\n"                                   \
	"\n"                                                                      \
	"\t\t} else {\n"                                                          \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tReduce action. (Reduce is < 0, and the production to reduce\n" \
	"\t\t\t *\tby is given below\n"                                           \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\taction = -action-1;\n"                                             \
	"\n"                                                                      \
	"\t\t\tif (!reduceByAction(action)) {\n"                                  \
	"\t\t\t\t// If there is an error, this handles the error.\n"              \
	"\t\t\t\t// (This should not happen in practice).\n"                      \
	"\t\t\t\terrorWithCode(ERROR_SYNTAX);\n"                                  \
	"\n"                                                                      \
	"\t\t\t\t// Advance to next token.\n"                                     \
	"\t\t\t\ta = lex->lex();\n"                                               \
	"\t\t\t}\n"                                                               \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"}\n";


/************************************************************************/
/*																		*/
/*	Construction/Destruction											*/
/*																		*/
/************************************************************************/

/*	OCYaccCPPGenerator::OCYaccCPPGenerator
 *
 *		Construt this class
 */

OCYaccCPPGenerator::OCYaccCPPGenerator(const OCYaccParser &p, const OCYaccLR1 &y) : parser(p), state(y)
{
}

/*	OCYaccCPPGenerator::~OCYaccCPPGenerator
 *
 *		Destructor
 */

OCYaccCPPGenerator::~OCYaccCPPGenerator()
{
}

/************************************************************************/
/*																		*/
/*	Support																*/
/*																		*/
/************************************************************************/

/*	OCYaccCPPGenerator::WriteRule
 *
 *		Write rule, translating $$ and $n, unless it's within a string.
 *	We detect strings by scanning for double quotes
 */

void OCYaccCPPGenerator::WriteRule(FILE *f, const OCYaccLR1::Reduction &rule)
{
	char q = 0;
	char buffer[256];
	std::string ret;

	const char *ptr = rule.code.c_str();

	while (*ptr) {
		// Skip anything following a backslash.
		char c = *ptr++;

		if (c == '\\') {
			ret.push_back(c);
			if (*ptr) {
				ret.push_back(*ptr++);
			}
			continue;
		}

		if ((c == '"') || (c == '\'')) {
			if (q == c) q = 0;
			else q = c;
		}

		// q is set if we're inside a string
		if (q) {
			ret.push_back(c);
			continue;
		}

		// We're not in a string. Scan for $
		if (c == '$') {
			if (*ptr == '$') {
				// $$; get type and prepend if not part of assignment
				++ptr;

				const char *x = ptr;
				while (isspace(*x)) ++x;
				bool isAssign = (*x == '=');

				if (isAssign) {
					ret += "s.value";
					if (rule.prodType.length() != 0) {
						ret += "." + rule.prodType;
					}
				} else {
					if (rule.prodType.length() == 0) {
						fprintf(stderr,"Warning: Production for rule %s has no type\n",rule.prodDebug.c_str());
						ret += "(s.value)";
					} else {
						ret += " (s.value.";
						ret += rule.prodType;
						ret += ")";
					}
				}
			} else if (isdigit(*ptr)) {
				// $n; extract number value and construct proper substitution
				size_t value = 0;
				while (isdigit(*ptr)) {
					value = (value * 10) + *ptr++ - '0';
				}

				if ((value < 1) || (value > rule.types.size())) {
					value = 1;

					fprintf(stderr,"Warning: Rule %s has illegal '$' specifier\n",rule.prodDebug.c_str());
					fprintf(stderr,"Code: %s\n",rule.code.c_str());
				}

				/*
				 *	Determine if we have one of the special fields, _file, _line,
				 *	_col. This allows us to extract the current token location of
				 *	a symbol
				 */

				if (*ptr == '_') {
					std::string param;
					++ptr;
					while (isalnum(*ptr)) {
						param.push_back(*ptr++);
					}

					if (value == 1) {
						ret += "(stack[pos].";
					} else {
						sprintf(buffer,"(stack[pos + %zu].",value-1);
						ret += buffer;
					}

					if (param == "file") {
						ret += "filename)";
					} else if (param == "line") {
						ret += "line)";
					} else if (param == "col") {
						ret += "column)";
					} else {
						ret += "state)";
						fprintf(stderr,"Warning: Unknown synthetic type $%zu_%s\n",value,param.c_str());
					}

				} else {
					// Insert (type *) if type is defined
					std::string valueType = rule.types[value-1];

					if (value == 1) {
						ret += "(stack[pos].value";
					} else {
						sprintf(buffer,"(stack[pos + %zu].value",value-1);
						ret += buffer;
					}

					if (valueType.size() > 0) {
						ret += ".";
						ret += valueType;
					} else {
						fprintf(stderr,"Warning: Rule %s, $%zu has no type\n",rule.prodDebug.c_str(),value);
					}

					ret.push_back(')');
				}

			} else {
				// ???
				ret.push_back(c);
			}
		} else {
			ret.push_back(c);
		}
	}

	/*
	 *	Print rule with 12 space prefix
	 */

	if (ret.length()) {
		fprintf(f,"                %s\n",ret.c_str());
	}
}

/*	OCYaccCPPGenerator::WriteYTables
 *
 *		Write the files
 */

void OCYaccCPPGenerator::WriteYTables(FILE *f)
{
	size_t i,len;
	char buffer[64];

	// Constants to print
	fprintf(f,"// Various constants\n");
	fprintf(f,"#define K_ACCEPTSTATE       %-8zu     // Final accept state\n",state.accept);
	fprintf(f,"#define K_EOFTOKEN          0x%-8x   // EOF token ID\n",state.eofTokenID);
	fprintf(f,"#define K_ERRORTOKEN        0x%-8x   // Error token ID\n",state.errorTokenID);
	fprintf(f,"#define K_FIRSTTOKEN        0x%-8x   // Error token ID\n",state.firstTokenID);
	fprintf(f,"#define K_MAXSYMBOL         0x%-8x   // Max ID for all symbols\n",state.maxSymbolID);
	fprintf(f,"#define K_STARTSTATE		0            // Start state is always 0\n");

	// Non-Unicode tokens
	fprintf(f,"\n/*  TokenArray\n");
	fprintf(f," *\n");
	fprintf(f," *      Array of non-Unicode token values for error reporting\n");
	fprintf(f," */\n\n");

	bool first = true;
	fprintf(f,"static const char *TokenArray[] = {\n");
	std::vector<OCYaccLR1::TokenConstant>::const_iterator tokIter;
	for (tokIter = state.tokens.cbegin(); tokIter != state.tokens.cend(); ++tokIter) {
		if (first) {
			first = false;
			fprintf(f,"    ");
		} else {
			fprintf(f,",\n    ");
		}
		fprintf(f,"\"%s\"",tokIter->token.c_str());
	}
	fprintf(f,"\n};\n\n");

	// Reduction table
	len = state.reductions.size();
	fprintf(f,"/*  RuleLength\n *\n *      The number of tokens a reduce action removes from the stack\n */\n\n");
	fprintf(f,"static const uint8_t RuleLength[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%2zu",state.reductions[i].reduce);
	}
	fprintf(f,"\n};\n");

	len = state.reductions.size();
	fprintf(f,"\n/*  RuleProduction\n *\n *      The prodution ID we reduce to\n */\n\n");
	fprintf(f,"static const uint32_t RuleProduction[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		sprintf(buffer,"0x%x",state.reductions[i].production);
		fprintf(f,"%8s",buffer);
	}
	fprintf(f,"\n};\n\n");

	// Action tables
	fprintf(f,"/*\n *  The following tables are compressed using CSR format.\n");
	fprintf(f," *  See https://en.wikipedia.org/wiki/Sparse_matrix\n");
	fprintf(f," */\n\n");

	fprintf(f,"/*  ActionI, J, A\n *\n *      Compressed action index table.\n */\n\n");
	len = state.actionI.size();
	fprintf(f,"static const uint32_t ActionI[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%6zu",state.actionI[i]);
	}
	fprintf(f,"\n};\n\n");

	len = state.actionJ.size();
	fprintf(f,"static const uint32_t ActionJ[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		uint32_t token = state.actionJ[i];
		if ((32 < token) && (token < 127) && (token != '\'') && (token != '\\')) {
			sprintf(buffer,"'%c'",(char)token);
		} else {
			sprintf(buffer,"0x%x",token);
		}
		fprintf(f,"%8s",buffer);
	}
	fprintf(f,"\n};\n\n");

	len = state.actionA.size();
	fprintf(f,"// Note: < 0 -> reduce (rule = -a-1), >= 0 -> shift (state).\n");
	fprintf(f,"static const int16_t ActionA[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		int32_t val = (int32_t)(state.actionA[i].value);
		if (state.actionA[i].reduce) {
			val = -val-1;
		}

		fprintf(f,"%6d",val);
	}
	fprintf(f,"\n};\n\n");

	// Goto table
	fprintf(f,"/*  GotoI, J, A\n *\n *      Compressed goto table.\n */\n\n");
	len = state.actionI.size();
	fprintf(f,"static const uint32_t GotoI[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%6zu",state.gotoI[i]);
	}
	fprintf(f,"\n};\n\n");

	len = state.gotoJ.size();
	fprintf(f,"static const uint32_t GotoJ[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		sprintf(buffer,"0x%x",state.gotoJ[i]);
		fprintf(f,"%8s",buffer);
	}
	fprintf(f,"\n};\n\n");

	len = state.gotoA.size();
	fprintf(f,"static const int16_t GotoA[%zu] = {\n",len);
	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		int32_t val = (int32_t)(state.gotoA[i]);

		fprintf(f,"%6d",val);
	}
	fprintf(f,"\n};\n\n");
}

/************************************************************************/
/*																		*/
/*	Write Files															*/
/*																		*/
/************************************************************************/

/*	OCYaccCPPGenerator::WriteOCFile
 *
 *		Write the header
 */

void OCYaccCPPGenerator::WriteOCFile(const char *classname, const char *outputName, FILE *f)
{
	std::string lexerClass;
	if (parser.lexerClass.size() > 0) {
		lexerClass = parser.lexerClass;
	} else {
		lexerClass = classname;
		lexerClass += "Input";
	}

	// Prefix
	fprintf(f,GSource1,outputName,outputName);

	// If we define a lex header, insert it
	if (parser.lexerHeader.size() > 0) {
		fprintf(f,"#include \"%s\"\n",parser.lexerHeader.c_str());
	}

	// Print states, declarations and constants
	fprintf(f,"%s",GSource2);

	// Write the various tables
	WriteYTables(f);

	// Start generating the rest of the file
	fprintf(f, GSource3, classname, classname, lexerClass.c_str());

	// Insert initializers
	fprintf(f, "%s\n", parser.classInit.c_str());

	// Close class internal, start class
	fprintf(f, GSource4, classname, classname);

	// Dealloc code
	fprintf(f, "%s\n", parser.classFinish.c_str());

	fprintf(f,"%s",GSource5);

	// Class code
	fprintf(f, "%s\n", parser.endCode.c_str());

	// Production (to switch statement)
	fprintf(f, GSource6, classname, classname, classname, classname);

	// Print information about the rules we're reducing by
	fprintf(f,"\n        // Production rules\n");
	size_t i,len = state.reductions.size();
	for (i = 0; i < len; ++i) {
		fprintf(f,"            // (%x) %s\n",state.reductions[i].production,state.reductions[i].prodDebug.c_str());
		if (state.reductions[i].code.length() > 0) {
			fprintf(f,"            case %zu:\n",i);
			fprintf(f,"                {\n");
			WriteRule(f, state.reductions[i]);
			fprintf(f,"                }\n");
			fprintf(f,"                break;\n\n");
		}
	}
	fprintf(f,"\n");

	// Close switch, finish writing the rest
	fprintf(f, GSource7, classname, classname, classname, classname,
						 classname, classname, classname, classname,
						 classname, classname, classname, classname,
						 classname, classname, classname, classname);

	if (parser.valueUnion.size() > 0) {
		fprintf(f,"\t\t\t\t\tstmp.value = lex->value;\n");
	}

	fprintf(f, GSource8, classname, classname);

	if (parser.valueUnion.size() > 0) {
		fprintf(f,"\t\t\t\tstmp.value = lex->value;\n");
	}

	fprintf(f, GSource9, classname);

	if (parser.valueUnion.size() > 0) {
		fprintf(f,"\t\t\tstmp.value = lex->value;\n");
	}

	fprintf(f, "%s", GSource10);
}

/*	OCYaccCPPGenerator::WriteOCHeader
 *
 *		Write the header
 */

void OCYaccCPPGenerator::WriteOCHeader(const char *classname, const char *outputName, FILE *f)
{
	const char *lexerClass;
	if (parser.lexerClass.size() > 0) {
		lexerClass = parser.lexerClass.c_str();
	} else {
		lexerClass = classname;
	}

	// Prefix
	fprintf(f,GHeader1,outputName,outputName,outputName);

	// Includes declarations
	fprintf(f,"%s\n",parser.classHeader.c_str());

	// Header declarations
	fprintf(f,"%s\n",parser.declCode.c_str());

	// Forwards
	fprintf(f,GHeader2,classname);

	// Yacc constants
	std::vector<OCYaccLR1::TokenConstant>::const_iterator tokIter;
	for (tokIter = state.tokens.cbegin(); tokIter != state.tokens.cend(); ++tokIter) {
		fprintf(f,"#define %-45s 0x%08x\n",tokIter->token.c_str(),tokIter->value);
//		if (!tokIter->used) {
//			fprintf(f,"   /* Unused */\n");
//		} else {
//			fprintf(f,"\n");
//		}
	}

	// If we define our union, generate the union definition
	if (parser.valueUnion.size() > 0) {
		fprintf(f,"\n");
		fprintf(f,"#ifndef %s_ValueDefined\n",lexerClass);
		fprintf(f,"#define %s_ValueDefined\n",lexerClass);
		fprintf(f,"\n");
		fprintf(f,"/*  %sValue\n",lexerClass);
		fprintf(f," *\n");
		fprintf(f," *      Internally defined value.\n");
		fprintf(f," */\n\n");
		fprintf(f,"union %sValue {\n",lexerClass);
		fprintf(f,"    %s",parser.valueUnion.c_str());
		fprintf(f,"};\n\n");
		fprintf(f,"#endif\n");
	}

	// Bulk of declarations
	fprintf(f,"%s",GHeader3);

	// Errors
	fprintf(f,"%s\n",parser.classErrors.c_str());

	if (parser.lexerClass.size() > 0) {
		fprintf(f,"class %s;\n",parser.lexerClass.c_str());
	} else {
		/*
		 *	Generate the code for the generic protocol. When we do this
		 *	we generate three new symbols:
		 *
		 *		(classname)Input  -- the name of the input protocol
		 *		(classname)InputProtocol -- the #define
		 *		(classname)Value -- the union value of the values
		 */

		fprintf(f,GHeader3a,classname,classname,classname,classname);
		if (parser.valueUnion.size() > 0) {
			fprintf(f,"\t\tunion %sValue value;\n",classname);
		}
		fprintf(f,"%s",GHeader3a1);
	}
	fprintf(f,GHeader3b,classname);
	if (parser.valueUnion.size() > 0) {
		fprintf(f,"\tunion %sValue value;\n",lexerClass);
	}

	/*
	 *	The constructor; generate the correct lexer class name for input
	 */

	if (parser.lexerClass.size() > 0) {
		fprintf(f,GHeader3c,classname,classname,classname,lexerClass,classname);

		// Class globals
		fprintf(f,"\n%s\n",parser.classGlobal.c_str());

		// Private
		fprintf(f,GHeader4,classname,lexerClass,classname);
	} else {
		std::string abstractName = lexerClass;
		abstractName.append("Input");
		fprintf(f,GHeader3c,classname,classname,classname,abstractName.c_str(),classname);

		// Class globals
		fprintf(f,"\n%s\n",parser.classGlobal.c_str());

		// Private
		fprintf(f,GHeader4,classname,abstractName.c_str(),classname);
	}

	// Insert class declarations
	fprintf(f,"%s",parser.classLocal.c_str());

	fprintf(f,"%s",GHeader5);
}
