/*	OCYaccTest.m
 *
 *		This file was automatically generated by OCYacc, part of the OCTools
 *	suite available at:
 *
 *		https://github.com/w3woody/OCTools
 */

#import "OCYaccTest.h"


/*
 *	Note: this is a baseline implementation for an LR parser as described in
 *	Aho, Sethi, Ullman: "Compilers: Principles, Techniques and Tools", (the
 *	Dragon Book), pages 216-220. Unlike the example there we don't bother 
 *	storing the tokens on the token stack. We also take some liberties to
 *	compress our tables, and do a few optimizations similar to Bison.
 *
 *	Table compression scheme comes from
 *
 *	https://en.wikipedia.org/wiki/Sparse_matrix
 *
 *	A discussion of the Bison internals comes from
 *
 *	https://www.cs.uic.edu/~spopuri/cparser.html
 */

/************************************************************************/
/*                                                                      */
/*  State Tables and Constants                                          */
/*                                                                      */
/************************************************************************/

// Various constants
#define K_ACCEPTSTATE       6            // Final accept state
#define K_EOFTOKEN          0x110000     // EOF token ID
#define K_ERRORTOKEN        0x110001     // Error token ID
#define K_FIRSTTOKEN        0x110002     // Error token ID
#define K_MAXSYMBOL         0x110009     // Max ID for all symbols
#define K_STARTSTATE		0            // Start state is always 0

/*  TokenArray
 *
 *      Array of non-Unicode token values for error reporting
 */

static NSString *TokenArray[] = {
    @"TOKEN",
    @"NUMBER"
};

// Production rules
// (110004) $accept : statements $end
// (110005) assignment : TOKEN '=' expression 
// (110005) assignment : TOKEN '=' assignment 
// (110006) expression : '(' expression ')' 
// (110006) expression : expression '+' expression 
// (110006) expression : expression '-' expression 
// (110006) expression : expression '*' expression 
// (110006) expression : expression '/' expression 
// (110006) expression : NUMBER 
// (110006) expression : TOKEN 
// (110007) statement : assignment ';' 
// (110007) statement : error ';' 
// (110008) statements : statement 
// (110008) statements : statements statement 

/*  RuleLength
 *
 *      The number of tokens a reduce action removes from the stack
 */

static uint8_t RuleLength[14] = {
     1,  3,  3,  3,  3,  3,  3,  3, 
     1,  1,  2,  2,  1,  2
};

/*  RuleProduction
 *
 *      The prodution ID we reduce to
 */

static uint32_t RuleProduction[14] = {
    0x110004, 0x110005, 0x110005, 0x110006, 0x110006, 0x110006, 0x110006, 0x110006, 
    0x110006, 0x110006, 0x110007, 0x110007, 0x110008, 0x110008
};

/*
 *  The following tables are compressed using CSR format.
 *  See https://en.wikipedia.org/wiki/Sparse_matrix
 */

/*  ActionI, J, A
 *
 *      Compressed action index table.
 */

static uint32_t ActionI[41] = {
         0,      2,      3,      4,      5,      8,     11,     12, 
        15,     18,     21,     24,     30,     35,     36,     41, 
        44,     47,     50,     53,     58,     63,     68,     73, 
        78,     81,     86,     91,     96,    101,    104,    107, 
       110,    113,    118,    123,    128,    133,    138,    143, 
       146
};

static uint32_t ActionJ[146] = {
    0x110001, 0x110002,      ';',      '=',      ';', 0x110000, 0x110001, 0x110002, 
    0x110000, 0x110001, 0x110002, 0x110000, 0x110000, 0x110001, 0x110002, 0x110000, 
    0x110001, 0x110002,      '(', 0x110002, 0x110003,      '(', 0x110002, 0x110003, 
         '*',      '+',      '-',      '/',      ';',      '=',      '*',      '+', 
         '-',      '/',      ';',      ';',      '*',      '+',      '-',      '/', 
         ';',      '(', 0x110002, 0x110003,      '(', 0x110002, 0x110003,      '(', 
    0x110002, 0x110003,      '(', 0x110002, 0x110003,      '*',      '+',      '-', 
         '/',      ';',      '*',      '+',      '-',      '/',      ';',      '*', 
         '+',      '-',      '/',      ';',      '*',      '+',      '-',      '/', 
         ';',      '*',      '+',      '-',      '/',      ';',      '(', 0x110002, 
    0x110003,      ')',      '*',      '+',      '-',      '/',      ')',      '*', 
         '+',      '-',      '/',      ')',      '*',      '+',      '-',      '/', 
         '*',      '+',      '-',      '/',      ';',      '(', 0x110002, 0x110003, 
         '(', 0x110002, 0x110003,      '(', 0x110002, 0x110003,      '(', 0x110002, 
    0x110003,      ')',      '*',      '+',      '-',      '/',      ')',      '*', 
         '+',      '-',      '/',      ')',      '*',      '+',      '-',      '/', 
         ')',      '*',      '+',      '-',      '/',      ')',      '*',      '+', 
         '-',      '/',      ')',      '*',      '+',      '-',      '/', 0x110000, 
    0x110001, 0x110002
};

// Note: < 0 -> reduce (rule = -a-1), >= 0 -> shift (state).
static int16_t ActionA[146] = {
         1,      2,     39,      9,      8,    -13,    -13,    -13, 
         6,      1,      2,     -1,    -14,    -14,    -14,    -11, 
       -11,    -11,     10,     11,     12,     24,     25,     26, 
       -10,    -10,    -10,    -10,    -10,      9,     -9,     -9, 
        -9,     -9,     -9,     -3,     15,     16,     17,     18, 
        -2,     10,     19,     12,     10,     19,     12,     10, 
        19,     12,     10,     19,     12,    -10,    -10,    -10, 
       -10,    -10,     -8,     -8,     -8,     -8,     -8,     15, 
        16,     17,     18,     -6,     15,     16,     17,     18, 
        -5,     -7,     -7,     -7,     -7,     -7,     24,     25, 
        26,    -10,    -10,    -10,    -10,    -10,     -9,     -9, 
        -9,     -9,     -9,     28,     29,     30,     31,     32, 
        -4,     -4,     -4,     -4,     -4,     24,     25,     26, 
        24,     25,     26,     24,     25,     26,     24,     25, 
        26,     -8,     -8,     -8,     -8,     -8,     -6,     29, 
        30,     31,     32,     -5,     29,     30,     31,     32, 
        -7,     -7,     -7,     -7,     -7,     38,     29,     30, 
        31,     32,     -4,     -4,     -4,     -4,     -4,    -12, 
       -12,    -12
};

/*  GotoI, J, A
 *
 *      Compressed goto table.
 */

static uint32_t GotoI[41] = {
         0,      3,      3,      3,      3,      3,      5,      5, 
         5,      5,      7,      8,      8,      8,      8,      8, 
         9,     10,     11,     12,     12,     12,     12,     12, 
        12,     13,     13,     13,     13,     13,     14,     15, 
        16,     17,     17,     17,     17,     17,     17,     17, 
        17
};

static uint32_t GotoJ[17] = {
    0x110005, 0x110007, 0x110008, 0x110005, 0x110007, 0x110005, 0x110006, 0x110006, 
    0x110006, 0x110006, 0x110006, 0x110006, 0x110006, 0x110006, 0x110006, 0x110006, 
    0x110006
};

static int16_t GotoA[17] = {
         3,      4,      5,      3,      7,     13,     14,     27, 
        23,     22,     21,     20,     37,     36,     35,     34, 
        33
};

/************************************************************************/
/*                                                                      */
/*  Internal Structures													*/
/*                                                                      */
/************************************************************************/

/*
 *	Internal parser stack
 */

@interface OCYaccTestStack: NSObject			// ###TODO Rename according to class name
@property (assign) uint16_t state;

/* Represent the intermediate values for reduction rule values */
@property (strong) id<NSObject> value;
@end

@implementation OCYaccTestStack
@end

/************************************************************************/
/*                                                                      */
/*  Parser Code															*/
/*                                                                      */
/************************************************************************/

/*
 *	Class internals
 */

@interface OCYaccTest ()
@property (strong) NSMutableArray<OCYaccTestStack *> *stack;
@property (strong) id<OCLexInput> lex;

// Error support
@property (assign) NSInteger line;
@property (assign) NSInteger column;
@property (copy) NSString *filename;

@property (assign) NSInteger errorCount;

// Yacc class declarations

@end

/*
 *	Generated class
 */

@implementation OCYaccTest

/*
 *	Startup
 */

- (instancetype)initWithLexer:(id<OCLexInput>)lexer
{
	if (nil != (self = [super init])) {
		self.lex = lexer;

		/*
		 *	Alloc stack
		 */

		self.stack = [[NSMutableArray alloc] init];
	}
	return self;
}



/*
 *	Process production rule. This processes the production rule and creates
 *	a new stack state with the rule reduction.
 */

- (OCYaccTestStack *)processReduction:(NSInteger)rule
{
	// Get production len, for translating $1...$N into something useful
	NSInteger pos = self.stack.count - RuleLength[rule];

	// Set up initial state.
	OCYaccTestStack *s = [[OCYaccTestStack alloc] init];

	// Now process production.
	//
	// Note that $$ translated into (s.value), and
	// $n translates into ((<type> *)(self.stack[pos+(n-1)])), where <type>
	// is the declared type of the token or production rule.

	@try {
		switch (rule) {
			default:
				break;
		}
	}
	@catch (NSException *exception) {
		/* This can happen in the event we start seeing errors */
	}

	return s;
}

/*
 *	Look up the action value for the state and token values provided. This
 *	parses through the ActionI, ActionJ and ActionA lists to find the correct
 *	entry. This returns NSIntegerMax if a value was not found, and this is an
 *	error entry.
 */

- (NSInteger)actionForState:(NSInteger)state token:(NSInteger)token
{
	size_t min,max,mid;

	/* Deal with EOF case */
	if (token == -1) token = K_EOFTOKEN;

	/* Find range */
	min = ActionI[state];
	max = ActionI[state+1];

	/* Binary search for value in ja */
	while (min < max) {
		mid = (min + max)/2;
		NSInteger j = ActionJ[mid];
		if (token == j) {
			return ActionA[mid];
		} else if (token < j) {
			max = mid;
		} else {
			min = mid+1;
		}
	}
	return NSIntegerMax;
}

/*
 *	Look up the goto value for the state and token (production rule) provided.
 *	Operates the same as actionForState, except we look in the goto table.
 *	In teory I guess we could combine these two tables (as productions and
 *	tokens do not overlap).
 */

- (NSInteger)gotoForState:(NSInteger)state production:(NSInteger)token
{
	size_t min,max,mid;

	/* Find range */
	min = GotoI[state];
	max = GotoI[state+1];

	/* Binary search for value in ja */
	while (min < max) {
		mid = (min + max)/2;
		NSInteger j = GotoJ[mid];
		if (token == j) {
			return GotoA[mid];
		} else if (token < j) {
			max = mid;
		} else {
			min = mid+1;
		}
	}
	return NSIntegerMax;
}

/*
 *	Errors. This formats and prints the specified error
 */

- (void)errorWithFormat:(NSString *)format,...
{
	if (self.errorDelegate == nil) return;	// No error handling, ignore.

	if (self.errorCount > 0) return;		// skip until synced on 3 shifts

	// Format string
	va_list vlist;
	va_start(vlist, format);
	NSString *msg = [[NSString alloc] initWithFormat:format arguments:vlist];
	va_end(vlist);

	// Call delegate with current token position
	[self.errorDelegate errorFrom:self line:self.line column:self.column filename:self.filename errorMessage:msg];

	// And now skip the next 3 token shifts so we don't spew garbage.
	self.errorCount = 3;
}

- (void)errorOK
{
	self.errorCount = 0;
}

- (NSString *)tokenToString:(uint32_t)token
{
	if (token >= K_FIRSTTOKEN) {
		return TokenArray[token - K_FIRSTTOKEN];
	} else if (token <= 0xFFFF) {
		return [NSString stringWithFormat:@"%C",(unichar)token];
	} else {
		// Extended UTF-32 character.
		unichar c[2];
		token -= 0x10000;	// Convert to two UTF-16 words
		c[0] = 0xD800 | (0x3FF & (token >> 10));
		c[1] = 0xDC00 | (0x3FF & token);
		return [NSString stringWithCharacters:c length:2];
	}
}

- (BOOL)reduceByAction:(int16_t)action
{
	// Determine the new state we're transitioning to.
	uint32_t production = RuleProduction[action];
	NSInteger length = RuleLength[action];

	// We pull the state we'd have after popping the stack.
	NSInteger statep = self.stack[[self.stack count] - length - 1].state;

	// Now calculate the state we should transition to
	NSInteger newState = [self gotoForState:statep production:production];
	if (newState == NSIntegerMax) return NO;

	// Process production rule, which generates the new state
	OCYaccTestStack *state = [self processReduction:action];

	// Update state
	state.state = newState;

	// Pop the stack
	[self.stack removeObjectsInRange:NSMakeRange(self.stack.count - length, length)];

	// Push new state
	[self.stack addObject:state];

	// Done.
	return YES;
}

/*
 *	Parser engine. Returns NO if there was an error during processing. Note
 *	that as we uncover errors we call our delegate for error handling. This
 *	implements the algorithm described in the Dragon Book, Algorithm 4.7.
 */

- (BOOL)parse
{
	BOOL success = YES;
	OCYaccTestStack *s;				// state
	NSInteger a;				// lex symbol

	/*
	 *	Step 1: reset and push the empty state.
	 */

	[self.stack removeAllObjects];

	s = [[OCYaccTestStack alloc] init];
	s.state = K_STARTSTATE;
	[self.stack addObject:s];

	/*
	 *	Now repeat forever:
	 */

	a = [self.lex lex];

	for (;;) {
		s = [self.stack lastObject];

		/*
		 *	Determine if this is the end state. If so, then we immediately
		 *	quit. We assume the user has set the production rule at the 
		 *	top, so we can simply drop the stack
		 */

		if (s.state == K_ACCEPTSTATE) {
			[self.stack removeAllObjects];
			return success;
		}

		/*
		 *	Now determine the action and shift, reduce or handle error as
		 *	appropriate
		 */

		NSInteger action = [self actionForState:s.state token:a];

		if (action == NSIntegerMax) {
			/*
			 *	Handle error. First, note we have an error, and note the
			 *	symbol on which our error took place.
			 */

			success = NO;		// regardless, we will always fail.
			self.filename = self.lex.filename;
			self.line = self.lex.line;
			self.column = self.lex.column;

			/*
			 *	First, scan backwards from the current state, looking for one
			 *	which has an 'error' symbol.
			 */

			NSInteger ix = self.stack.count;
			while (ix > 0) {
				OCYaccTestStack *si = self.stack[--ix];
				action = [self actionForState:si.state token:K_ERRORTOKEN];
				if ((action >= 0) && (action != NSIntegerMax)) {
					/*
					 *	Encountered error state. If the user has defined an
					 *	error token, we ultimately will want to (a) unwind
					 *	the stack until we find a state which handles the
					 *	error transition. We then .
					 */

					NSRange range = NSMakeRange(ix+1, self.stack.count - ix - 1);
					if (range.length) {
						[self.stack removeObjectsInRange:range];
					}

					/*
					 *	At this point we perform a shift to our new error
					 *	state.
					 */

					s = [[OCYaccTestStack alloc] init];
					s.state = action;
					s.value = self.lex.value;
					[self.stack addObject:s];

					/*
					 *	Second, we start pulling symbols until we find a symbol
					 *	that shifts, or until we hit the end of file symbol. 
					 *	This becomes our current token for parsing
					 */

					for (;;) {
						a = [self.lex lex];
						action = [self actionForState:s.state token:a];
						if ((action >= 0) && (action != NSIntegerMax)) {
							/*
							 *	Valid shift. This becomes our current token,
							 *	and we resume processing.
							 */

							continue;

						} else if (action == K_EOFTOKEN) {
							/*
							 *	We ran out of tokens. At this point all
							 *	we can do is print an error and force quit.
							 */

							[self errorWithFormat:@"Unrecoverable syntax error."];
							[self.stack removeAllObjects];

							return false;
						}
					}
				}
			}

			/*
			 *	If we reach this point, there is no error we can recover to.
			 *	So figure this out on our own.
			 *
			 *	First, we see if the state we're in has a limited number of
			 *	choices. For example, in C, the 'for' keyword will always be
			 *	followed by a '(' token, so we can offer to automatically 
			 *	insert that token.
			 */

			NSInteger actionMin = ActionI[s.state];
			NSInteger actionMax = ActionI[s.state + 1];
			NSInteger actionVal = actionMin;
			int16_t actionState = -1;
			for (NSInteger ix = actionMin; ix < actionMax; ++ix) {
				int16_t act = ActionA[ix];
				if (actionState == -1) {
					if (act >= 0) {
						actionState = act;
						actionVal = ix;
					}
				} else {
					actionState = -1;
					break;
				}
			}

			if (actionState != -1) {
				/*
				 *	We can accomplish this transition with one token. Print
				 *	an error, and do a shift on the state with an empty value.
				 */

				NSString *tokenStr = [self tokenToString:ActionJ[actionVal]];
				[self errorWithFormat:@"Missing %@ was inserted",tokenStr];

				/*
				 *	Perform a shift but do not pull a new token
				 */

				OCYaccTestStack *stack = [[OCYaccTestStack alloc] init];
				stack.state = actionState;
				stack.value = self.lex.value;

				[self.stack addObject:stack];
				continue;
			}

			/*
			 *	See if we have a limited choice in reductions. If this can
			 *	only reduce to a single state, try that reduction.
			 */

			actionState = 0;
			for (NSInteger ix = actionMin; ix < actionMax; ++ix) {
				int16_t act = ActionA[ix];
				if (actionState == 0) {
					if ((act < 0) && (actionState != act)) {
						actionState = act;
					}
				} else {
					actionState = 0;
					break;
				}
			}

			if (actionState != 0) {
				/*
				 *	We have one possible reduction. Try that. Note that this
				 *	will trigger a syntax error since we're reducing down 
				 *	without the follow token. My hope is that the state we
				 *	transition to has a limited set of next tokens to follow.
				 */

				[self reduceByAction:action];
				continue;
			}

			/*
			 *	If we have a limited number of tokens which can follow, 
			 *	print a list of them. Then shift by the first one we
			 *	find. We don't do this if the number of shifts is greater
			 *	than five.
			 */

			if (actionMax - actionMin <= 5) {
				NSMutableString *list = [[NSMutableString alloc] init];
				for (NSInteger ix = actionMin; ix < actionMax; ++ix) {
					[list appendFormat:@" %@",[self tokenToString:ActionJ[ix]]];
				}

				[self errorWithFormat:@"Expected one of%@",list];

				/*
				 *	Now we artificially insert the first of the list of
				 *	tokens as our action and continue.
				 */

				a = ActionJ[actionMin];
				continue;
			}

			/*
			 *	If we get here, things just went too far south. So we
			 *	skip a token, print syntax error and move on
			 */

			[self errorWithFormat:@"Syntax error; skipping next symbol"];
			a = [self.lex lex];

		} else if (action >= 0) {
			/*
			 *	Shift operation.
			 */

			// Shift
			OCYaccTestStack *stack = [[OCYaccTestStack alloc] init];
			stack.state = action;
			stack.value = self.lex.value;

			[self.stack addObject:stack];

			// Advance to next token.
			a = [self.lex lex];

			// Decrement our error count. If this is non-zero we're in an
			// error state, and we don't pass spurrous errors upwards
			if (self.errorCount) {
				self.errorCount = self.errorCount-1;
			}

		} else {
			/*
			 *	Reduce action. (Reduce is < 0, and the production to reduce
			 *	by is given below
			 */

			action = -action-1;

			if (![self reduceByAction:action]) {
				// If there is an error, this handles the error.
				// (This should not happen in practice).
				success = NO;
				[self errorWithFormat:@"Illegal token; skipping"];

				// Advance to next token.
				a = [self.lex lex];
			}
		}
	}
}

@end
