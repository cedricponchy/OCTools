/*	OCYacc.h
 *
 *		This file was automatically generated by OCYacc, part of the OCTools
 *	suite available at:
 *
 *		https://github.com/w3woody/OCTools
 */

#import "OCYacc.h"

#warning YACC Modification Notes

/*
 *	First, modify the lex generator to add an optional tokenValue object.
 *	This is used in place of yylval in Lex; the idea is that we can create
 *	objects associated with a token value and pass that into the token.
 *
 *	Second, omit the union directive. It's not needed given the third item
 *	below.
 *
 *	Third, parse the <value> symbol for %token, %type, etc. This represents
 *	the name of the Objective C class which is stored in the value object.
 *
 *	Fourth, as we generate code, replace
 *
 *		$$ and $n
 *
 *	with
 *
 *		((TokenValueClass *)(blahblahblah))
 *
 *	That is, the <value> represents the class name TokenValueClass, so we
 *	replace so we can handle classes. Note that this implies integer values
 *	must be passed as NSNumber, and using NSNumber as a value is legit.
 *
 *	Fifth, replace
 *
 *		$n_thing
 *
 *	with the appropriate code to pull line, column, filename, or text
 *	from the token. This allows us to write
 *
 *		$1_line
 *
 *	to get the line number. This can be used for error handling, or to get
 *	the string of the text (by writing $3_text, for example).
 */


/************************************************************************/
/*                                                                      */
/*  Yacc Transition State Tables                                        */
/*                                                                      */
/************************************************************************/

/*
 *	Note: this is a baseline implementation for an LR parser as described in
 *	Aho, Sethi, Ullman: "Compilers: Principles, Techniques and Tools", (the
 *	Dragon Book), pages 216-220. Unlike the example there we don't bother 
 *	storing the tokens on the token stack. We also take some liberties to
 *	compress our tables, and do a few optimizations similar to Bison.
 *
 *	Table compression scheme comes from
 *
 *	https://en.wikipedia.org/wiki/Sparse_matrix
 *
 *	A discussion of the Bison internals comes from
 *
 *	https://www.cs.uic.edu/~spopuri/cparser.html
 */

/*
 *  Constants
 */

#define MAXSTATES       12
#define MAXTOKENS		6
#define MAXSYMBOLS		3
#define MAXPRODUCTIONS  6

/*	SymbolList
 *
 *		This is a sorted list of symbols, and is used to map a lex symbol
 *	to an index value in the action table. The list is sorted so we can do
 *	an O(log(N)) lookup given a symbol value, to find the index that is then
 *	used in the table.
 *
 *		Yes, this slows down the parser, but it also keeps things smaller.
 *	Note that we also include the EOF as a symbol, as it is used for reduction.
 *	Illegal symbols are given as the value MAXSYMBOLS
 */

static NSInteger SymbolList[MAXTOKENS] = {
	-1, '(', ')', '*', '+', YACCTOKEN_ID
};

/*	ProductionLength
 *
 *		This array gives the number of symbols in a production rule. A
 *	production rule is of the form SYMBOL := symbol_list; multiple
 *	declarations for the same symbol are split across multiple productions.
 *
 *		This array gives the length of each production rule; this is the
 *	number of tokens we reduce the read stack when we encounter a rule that
 *	is to be reduced.
 */

static uint16_t ProductionLength[MAXPRODUCTIONS] = {
	3, 1, 3, 1, 3, 1
};

/*	ProductionSymbol
 *
 *		Each production represents the list of items which are converted
 *	to a single symbol. Our symbols are indexed from 0, and this shows
 *	which symbol each production rule reduces to
 */

static uint16_t ProductionSymbol[MAXPRODUCTIONS] = {
	0, 0, 1, 1, 2, 2
};

/*	GotoTable
 *
 *		This is the goto table as outlined on page 219 of the Dragon Book.
 *	Error slots use MAXSTATES as the value
 */

static uint16_t GotoTable[MAXSYMBOLS * MAXSTATES] = {
	1,	2,	3,
	12, 12, 12,
	12, 12, 12,
	12, 12, 12,
	8,	2,	3,
	12, 12, 12,
	12, 9,	3,
	12, 12, 10,
	12, 12, 12,
	12, 12, 12,
	12, 12, 12,
	12, 12, 12
};

/*	ActionTable
 *
 *		This is the action table as outlined on page 219 of the Dragon Book.
 *	Entries indicate both if this is a shift or reduction, and the state or
 *	production used to handle reduction. 
 *
 *		Each cell has the following format:
 *
 *	XXXX XXXX XXXX XXYZ
 *
 *		XX: The state/reduction rule index
 *		Y:  Terminal state if 1. If Z = 0, accept. If Z = 1, error.
 *		Z:	Shift if set, Reduce if clear.
 *
 *		Note: the final format may change. We may borrow a few hints from
 *	Bison to do two things:
 *
 *	(1) Use CSR sparse matrix formatting to eliminate error states, and use
 *		an ad-hoc error processing mechanism for sync and restart.
 *
 *		https://en.wikipedia.org/wiki/Sparse_matrix
 *
 *
 *	(2)	Use state wrappers to create a new start state and a new end state
 *		rule, so we can simplify end state detection.
 *
 *		https://www.cs.uic.edu/~spopuri/cparser.html
 */

static uint16_t ActionTable[MAXTOKENS * MAXSTATES] = {
	/*	$	(	)	*	+	ID */		/*	$	(	)	*	+	ID	*/
		3,	17,	3,	3,	3,	21,			/*		s4				s5	*/
		2,	3,	3,	3,	25,	3,			/*	acc				s6		*/
		8,	3,	8,	29,	8,	3,			/*	r2		r2	s7	r2		*/
		16,	3,	16,	16,	16,	3,			/*	r4		r4	r4	r4		*/
		3,	17,	3,	3,	3,	20,			/*		s4				s5	*/
		24,	3,	24,	24,	24,	3,			/*	r6		r6	r6	r6		*/
		3,	17,	3,	3,	3,	20,			/*		s4				s5	*/
		3,	17,	3,	3,	3,	20,			/*		s4				s5	*/
		3,	3,	45,	3,	25,	3,			/*			s11		s6		*/
		4,	3,	4,	29,	4,	3,			/*	r1		r1	s7	r1		*/
		12,	3,	12,	12,	12,	3,			/*	r3		r3	r3	r3		*/
		20,	3,	20,	20,	20,	3,			/*	r5		r5	r5	r5		*/
};

#define STARTSTATE		0				/* TODO: Is this always the case? */

/************************************************************************/
/*                                                                      */
/*  Internal Structures													*/
/*                                                                      */
/************************************************************************/

/* TODO: Rename relative to class name */

@interface OCYaccStack: NSObject
@property (assign) uint16_t state;

/* Represent the intermediate values for reduction rule values */
@property (strong) id<NSObject> value;

/* We track where we read each symbol for error reporting purposes */
@property (assign) NSInteger line;
@property (assign) NSInteger column;
@property (copy) NSString *filename;
@property (copy) NSString *text;
@end

@implementation OCYaccStack
@end

/************************************************************************/
/*                                                                      */
/*  Parser Code															*/
/*                                                                      */
/************************************************************************/

/*
 *	Class internals
 */

@interface OCYacc ()
@property (strong) NSMutableArray<OCYaccStack *> *stack;
@property (strong) id<OCLexInput> lex;
@end

/*
 *	Generated class
 */

@implementation OCYacc

/*
 *	Startup
 */

- (instancetype)initWithLexer:(id<OCLexInput>)lexer
{
	if (nil != (self = [super init])) {
		self.lex = lexer;

		/*
		 *	Alloc stack
		 */

		self.stack = [[NSMutableArray alloc] init];
	}
	return self;
}

/*
 *	Support; convert token to a symbol. We use an internal symbol index from
 *	0 in order to reduce the space of values to search.
 */

- (NSInteger)tokenToSymbol:(NSInteger)token
{
	size_t min = 0;
	size_t max = MAXTOKENS;
	size_t mid;

	while (min < max) {
		mid = (min + max)/2;
		NSInteger t = SymbolList[mid];
		if (token == t) return mid;
		if (token < t) {
			max = mid;
		} else {
			min = mid+1;
		}
	}
	return MAXTOKENS;
}

/*
 *	Process production rule. This processes the production rule and creates
 *	a new stack state with the rule reduction.
 */

- (OCYaccStack *)processReduction:(NSInteger)production
{
	// Set up initial state.
	NSInteger prodLen = ProductionLength[production];
	NSInteger sstart = [self.stack count] - prodLen;	// index of first symbol
	OCYaccStack *s = [[OCYaccStack alloc] init];

	// Transfer the line information of the first symbol to the new state.
	// This allows us to issue an error which points to the start of an
	// expression if, higher up, things go south
	OCYaccStack *tmp = self.stack[sstart];
	s.line = tmp.line;
	s.column = tmp.column;
	s.filename = tmp.filename;
	s.text = nil;			// Complex expression, so drop text

	// Now process production
	switch (production) {
		default:
			break;
		/* ### INSERT HERE */
	}

	return s;
}

/*
 *	Parser engine. Returns NO if there was an error during processing. Note
 *	that as we uncover errors we call our delegate for error handling. This
 *	implements the algorithm described in the Dragon Book, Algorithm 4.7.
 */

- (BOOL)parse
{
	BOOL success = YES;
	OCYaccStack *s;				// state
	NSInteger a;				// lex symbol

	/*
	 *	Step 1: push the empty state. 
	 */

	s = [[OCYaccStack alloc] init];
	s.state = STARTSTATE;
	[self.stack addObject:s];

	/*
	 *	Now repeat forever:
	 */

	a = [self tokenToSymbol:[self.lex lex]];

	for (;;) {
		s = [self.stack lastObject];

		if (a == MAXTOKENS) {
			// ### TODO: Error processing; illegal token
			success = NO;
			if (self.errorDelegate) {
				[self.errorDelegate errorFrom:self line:self.lex.line column:self.lex.column filename:self.lex.filename token:self.lex.text errorMessage:@"Illegal token; skipping."];
			}

			// Advance to next token.
			a = [self tokenToSymbol:[self.lex lex]];
			continue;
		}

		uint16_t action = ActionTable[a + s.state * MAXSYMBOLS];

		if ((action & 3) == 0) {
			// Get production ID
			NSInteger rule = (action>>2)-1;	// zero indexed. (TODO)

			// Determine the new state we're transitioning to.
			NSInteger symbol = ProductionSymbol[rule];
			NSInteger length = ProductionLength[rule];

			// We pull the state we'd have after popping the stack.
			uint16_t statep = self.stack[[self.stack count] - length].state;

			// Now calculate the state we should transition to
			NSInteger newState = GotoTable[symbol + statep * MAXSYMBOLS];
			if (newState == MAXSYMBOLS) {
				// If there is an error, this handles the error.
				// (This should not happen in practice)
				success = NO;
				if (self.errorDelegate) {
					[self.errorDelegate errorFrom:self line:self.lex.line column:self.lex.column filename:self.lex.filename token:self.lex.text errorMessage:@"Illegal token; skipping."];
				}

				// Advance to next token.
				a = [self tokenToSymbol:[self.lex lex]];
				continue;
			}

			// Process production rule, which generates the new state
			OCYaccStack *state = [self processReduction:rule];

			// Update state
			state.state = newState;

			// Pop the stack
			[self.stack removeObjectsInRange:NSMakeRange(self.stack.count - length, length)];

			// Push new state
			[self.stack addObject:state];

		} else if ((action & 3) == 1) {
			// Shift
			OCYaccStack *stack = [[OCYaccStack alloc] init];
			stack.state = action >> 2;
			stack.line = self.lex.line;
			stack.column = self.lex.column;
			stack.filename = self.lex.filename;
			stack.text = self.lex.text;
			stack.value = self.lex.value;

			[self.stack addObject:stack];

			// Advance to next token.
			a = [self tokenToSymbol:[self.lex lex]];

		} else if ((action & 3) == 2) {
			// Accept
			return success;

		} else {
			// Error
			// ### TODO
			success = NO;
			if (self.errorDelegate) {
				[self.errorDelegate errorFrom:self line:self.lex.line column:self.lex.column filename:self.lex.filename token:self.lex.text errorMessage:@"Syntax error; skipping."];
			}
			// Advance to next token.
			a = [self tokenToSymbol:[self.lex lex]];
			continue;
		}
	}
}


@end
