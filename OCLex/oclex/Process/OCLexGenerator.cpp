//
//  OCLexGenerator.cpp
//  oclex
//
//  Created by William Woody on 7/30/17.
//  Copyright Â© 2017 Glenview Software. All rights reserved.
//

#include "OCLexGenerator.h"

/************************************************************************/
/*																		*/
/*	Standard Header														*/
/*																		*/
/************************************************************************/

static const char *GHeader1 =
	"/*\t%s.h\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import <Foundation/Foundation.h>\n"                                     \
	"\n";

static const char *GHeader2 =
	"/*\tOCFileInput\n"                                                       \
	" *\n"                                                                    \
	" *\t\tThe input file stream must correspond to this interface to read\n" \
	" *\tthe contents of a file or data object. The byte returned is from 0 to 255,\n" \
	" *\tand EOF is marked with -1.\n"                                        \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCFileInputProtocol\n"                                           \
	"#define OCFileInputProtocol\n"                                           \
	"\n"                                                                      \
	"@protocol OCFileInput <NSObject>\n"                                      \
	"- (int)readByte;\n"                                                      \
	"- (int)peekByte;\n"                                                      \
	"@end\n"                                                                  \
	"\n"                                                                      \
	"#endif\n"                                                                \
	"\n"                                                                      \
	"/*\tOCLexInput\n"                                                        \
	" *\n"                                                                    \
	" *\t\tThe protocol for our lex reader file that the lex stream must\n"   \
	" *\tprovide. This is the same as the protocol generated as part of the OCYacc\n" \
	" *\toutput, and allows us to glue the Lexer and Parser together.\n"      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCLexInputProtocol\n"                                            \
	"#define OCLexInputProtocol\n"                                            \
	"\n"                                                                      \
	"@protocol OCLexInput <NSObject>\n"                                       \
	"- (NSInteger)line;\n"                                                    \
	"- (NSInteger)column;\n"                                                  \
	"- (NSString *)filename;\n"                                               \
	"- (NSString *)text;\n"                                                   \
	"- (NSString *)abort;\n"                                                  \
	"\n"                                                                      \
	"- (NSInteger)lex;\n"                                                     \
	"\n"                                                                      \
	"- (id<NSObject>)value;\n"                                                \
	"@end\n"                                                                  \
	"\n"                                                                      \
	"#endif\n"																  \
	"\n"                                                                      \
	"/*\t%s\n"                                                                \
	" *\n"                                                                    \
	" *\t\tThe generated lexical parser\n"                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@interface %s : NSObject <OCLexInput>\n"                                 \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tExternal interfaces\n"                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (instancetype)initWithStream:(id<OCFileInput>)file;\n"                 \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tCurrent reader state\n"                                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@property (assign) NSInteger line;\t\t// line of last read token\n"      \
	"@property (assign) NSInteger column;\t// column of last read token\n"    \
	"@property (copy)   NSString *filename;\t// marked filename (if provided)\n" \
	"@property (copy)   NSString *text;\t\t// string of last read token\n"    \
	"@property (assign) NSString *abort;\t\t// Set to abort string if problem\n" \
	"@property (strong) id<NSObject> value;\t// Lex/Yacc value of token (optional)\n"    \
	"\n"                                                                      \
	"- (NSInteger)lex;\t\t\t\t\t\t// Method to read next token\n"             \
	"\n";

static const char *GHeader3 =
	"@end\n";


/************************************************************************/
/*																		*/
/*	Standard Lex Body													*/
/*																		*/
/************************************************************************/

static const char *GSource1 =
	"/*\t%s.m\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import \"%s.h\"\n"                                                      \
	"\n";

static const char *GSource2 =
	"/*\n"                                                                    \
	" *\tInternal storage\n"                                                  \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@interface %s ()\n"                                                      \
	"{\n"                                                                     \
	"\t// Read position support\n"                                            \
	"\tNSInteger curLine;\n"                                                  \
	"\tNSInteger curColumn;\n"                                                \
	"\n"                                                                      \
	"\t// Mark location support\n"                                            \
	"\tNSInteger markLine;\n"                                                 \
	"\tNSInteger markColumn;\n"                                               \
	"\n"                                                                      \
	"\t// Mark buffer storage\n"                                              \
	"\tBOOL isMarked;\t\t\t\t\t\t\t// yes if we have mark set\n"              \
	"\tunsigned char *markBuffer;\t\t\t\t// mark buffer\n"                    \
	"\tNSInteger markSize;\t\t\t\t\t\t// bytes stored in buffer\n"            \
	"\tNSInteger markAlloc;\t\t\t\t\t// capacity of buffer\n"                 \
	"\n"                                                                      \
	"\t// Read cache\n"                                                       \
	"\tunsigned char *readBuffer;\t\t\t\t// read cache buffer\n"              \
	"\tNSInteger readPos;\t\t\t\t\t\t// Read position\n"                      \
	"\tNSInteger readSize;\t\t\t\t\t\t// size of data in read buffer\n"       \
	"\tNSInteger readAlloc;\t\t\t\t\t// Capacity of read cache\n"             \
	"\n"                                                                      \
	"\t// Text read buffer\n"                                                 \
	"\tunsigned char *textBuffer;\t\t\t\t// text cache for reading buffer\n"  \
	"\tNSInteger textMarkSize;\n"                                             \
	"\tNSInteger textSize;\n"                                                 \
	"\tNSInteger textAlloc;\n"                                                \
	"\t\n"                                                                    \
	"\t// State flags\n"                                                      \
	"\tuint64_t  states;\n"                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"@property (strong) id<OCFileInput> file;\n";

static const char *GSource3 =
	"@end\n"                                                                  \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tClass lexer\n"                                                       \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@implementation %s\n"                                                    \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInstantiate parser.\n"                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (instancetype)initWithStream:(id<OCFileInput>)file\n"                  \
	"{\n"                                                                     \
	"\tif (nil != (self = [super init])) {\n"                                 \
	"\t\tself.file = file;\n"                                                 \
	"\n"                                                                      \
	"\t\tisMarked = NO;\n"                                                    \
	"\t\tmarkSize = 0;\n"                                                     \
	"\t\tmarkAlloc = 256;\n"                                                  \
	"\t\tmarkBuffer = (unsigned char *)malloc(markAlloc);\n"                  \
	"\n"                                                                      \
	"\t\treadPos = 0;\n"                                                      \
	"\t\treadSize = 0;\n"                                                     \
	"\t\treadAlloc = 256;\n"                                                  \
	"\t\treadBuffer = (unsigned char *)malloc(readAlloc);\n"                  \
	"\n"                                                                      \
	"\t\ttextMarkSize = 0;\n"                                                 \
	"\t\ttextSize = 0;\n"                                                     \
	"\t\ttextAlloc = 256;\n"                                                  \
	"\t\ttextBuffer = (unsigned char *)malloc(textAlloc);\n"                  \
	"\t\t\n"                                                                  \
	"\t\tstates = 0;\n";


static const char *GSource4 =
	"\t}\n"                                                                   \
	"\treturn self;\n"                                                        \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tFree internal storage\n"                                             \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)dealloc\n"                                                       \
	"{\n"                                                                     \
	"\tif (markBuffer) free(markBuffer);\n"                                   \
	"\tif (readBuffer) free(readBuffer);\n"                                   \
	"\tif (textBuffer) free(textBuffer);\n"                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal read backtrack support. We implement the internal methods\n" \
	" *\tfor mark, unmark and reset to note the current file position. This is\n" \
	" *\tused by the lexer to unwind the read queue if we overread the number\n" \
	" *\tof characters during parsing\n"                                      \
	" *\n"                                                                    \
	" *\tIn essence, as we execute the DFA while we read characters, when we\n" \
	" *\tfind an end state, we mark the stream. Then we continue to read until\n" \
	" *\twe reach an error--at which point we rewind back to the mark location.\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tmark: note that we should cache characters being read so we can rewind\n" \
	" *\tto this location in the future\n"                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)mark\n"                                                          \
	"{\n"                                                                     \
	"\t/*\n"                                                                  \
	"\t *\tStore the current file location and enable marking. This has the side\n" \
	"\t *\teffect of flushing any previous mark buffer\n"                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tmarkLine = curLine;\n"                                                 \
	"\tmarkColumn = curColumn;\n"                                             \
	"\ttextMarkSize = textSize;\n"                                            \
	"\n"                                                                      \
	"\tisMarked = YES;\n"                                                     \
	"\tmarkSize = 0;\n"                                                       \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tReset: reset the buffer positions\n"                                 \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)reset\n"                                                         \
	"{\n"                                                                     \
	"\tif (!isMarked) return;\t// not marked, nothing to do.\n"               \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReset to the marked position. We maintain two mutable data objects,\n" \
	"\t *\tone which stores the data we\'re reading from (if any), and one which\n" \
	"\t *\tstores the marked data.\n"                                         \
	"\t *\n"                                                                  \
	"\t *\tReset does two things: it prepends the read buffer with the data we\n" \
	"\t *\tstored during the mark phase, and we clear the mark flag.\n"       \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize + readSize - readPos > readAlloc) {\n"                    \
	"\t\t/*\n"                                                                \
	"\t\t *\tResize to fit\n"                                                 \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tNSInteger toFit = markSize + readSize - readPos;\n"                  \
	"\t\ttoFit = (toFit + 255) & ~255;\t// align to 256 byte boundary\n"      \
	"\t\tif (toFit < 0) toFit = 256;\n"                                       \
	"\n"                                                                      \
	"\t\tunsigned char *ptr = (unsigned char *)realloc(readBuffer, toFit);\n" \
	"\t\tif (ptr == NULL) {\n"                                                \
	"\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\treadBuffer = ptr;\n"                                                 \
	"\t\treadAlloc = toFit;\n"                                                \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the contents of the read buffer to a location above where the\n" \
	"\t *\tmark queue will go\n"                                              \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tmemmove(markSize + readBuffer, readPos + readBuffer, readSize - readPos);\n" \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the marked data\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize > 0) {\n"                                                 \
	"\t\tmemmove(readBuffer, markBuffer, markSize);\n"                        \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the read buffer settings\n"                                 \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treadSize = markSize + readSize - readPos;\n"                           \
	"\treadPos = 0;\n"                                                        \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tClear the mark\n"                                                  \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tisMarked = NO;\n"                                                      \
	"\tmarkSize = 0;\n"                                                       \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the file position\n"                                        \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tcurLine = markLine;\n"                                                 \
	"\tcurColumn = markColumn;\n"                                             \
	"\ttextSize = textMarkSize;\n"                                            \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead input stream.\n"                                                \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (int)input\n"                                                          \
	"{\n"                                                                     \
	"\tint ch;\n"                                                             \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tLow level: read, if from marked buffer\n"                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tch = readBuffer[readPos++];\n"                                       \
	"\t} else {\n"                                                            \
	"\t\tch = [self.file readByte];\n"                                        \
	"\n"                                                                      \
	"\t\tif (ch == -1) return -1;\t\t// At EOF; immediate return.\n"          \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate file position\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (ch == \'\\n\') {\n"                                                \
	"\t\tcurColumn = 0;\n"                                                    \
	"\t\t++curLine;\n"                                                        \
	"\t} else {\n"                                                            \
	"\t\t++curColumn;\n"                                                      \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tHandle mark\n"                                                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (isMarked) {\n"                                                     \
	"\t\tif (markSize >= markAlloc) {\n"                                      \
	"\t\t\tNSInteger toFit = (markAlloc + 256) & ~255;\n"                     \
	"\t\t\tif (toFit < 256) toFit = 256;\n"                                   \
	"\t\t\tunsigned char *ptr = (unsigned char *)realloc(markBuffer, toFit);\n" \
	"\t\t\tif (ptr == NULL) {\n"                                              \
	"\t\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\tmarkBuffer = ptr;\n"                                               \
	"\t\t\tmarkAlloc = toFit;\n"                                              \
	"\t\t}\n"                                                                 \
	"\t\tmarkBuffer[markSize++] = (unsigned char)ch;\n"                       \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReturn read character.\n"                                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treturn ch;\n"                                                          \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead ahead to determine if we\'re at the EOL\n"                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (BOOL)atEOL\n"                                                         \
	"{\n"                                                                     \
	"\tint ch;\n"                                                             \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tch = readBuffer[readPos];\n"                                         \
	"\t} else {\n"                                                            \
	"\t\tch = [self.file peekByte];\n"                                        \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\tif ((ch == -1) || (ch == \'\\n\')) return YES;\n"                      \
	"\treturn NO;\n"                                                          \
	"}\n"																	  \
	"\n"                                                                      \
	"- (BOOL)atSOL\n"                                                         \
	"{\n"                                                                     \
	"\treturn self.column == 0;\n"                                            \
	"}\n"																	  \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead the state for the class/state combination. Decodes the sparce \n" \
	" *\tmatrix that is compressed in StateMachineIA/JA/A above. If the\n"    \
	" *\tentry is not found, returns MAXSTATES. This is the same as the lookup\n" \
	" *\tStateMachine[class][state] if the StateMachine sparse array was\n"   \
	" *\tunrolled\n"                                                          \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (uint16_t)stateForClass:(uint16_t)charClass state:(uint16)state\n"     \
	"{\n"                                                                     \
	"\tsize_t min,max,mid;\n"                                                 \
	"\n"                                                                      \
	"\t/* Find range */\n"                                                    \
	"\tmin = StateMachineIA[state];\n"                                        \
	"\tmax = StateMachineIA[state+1];\n"                                      \
	"\n"                                                                      \
	"\t/* Binary search for value in ja */\n"                                 \
	"\twhile (min < max) {\n"                                                 \
	"\t\tmid = (min + max)/2;\n"                                              \
	"\t\tuint16_t j = StateMachineJA[mid];\n"                                 \
	"\t\tif (charClass == j) {\n"                                             \
	"\t\t\treturn StateMachineA[mid];\n"                                      \
	"\t\t} else if (charClass < j) {\n"                                       \
	"\t\t\tmax = mid;\n"                                                      \
	"\t\t} else {\n"                                                          \
	"\t\t\tmin = mid+1;\n"                                                    \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"\treturn MAXSTATES;\n"                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal methods declared within the Lex file\n"                     \
	" */\n";

static const char *GSource5 =
	"/*\n"                                                                    \
	" *\tLex interpreter. This runs the state machine until we find something\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (NSInteger)lex\n"                                                      \
	"{\n"                                                                     \
	"\tuint16_t state;\n"                                                     \
	"\tuint16_t action = MAXACTIONS;\n"                                       \
	"\n"                                                                      \
	"\tself.abort = NULL;\n"                                                  \
	"\tself.value = NULL;\n"                                                  \
	"\tself.text = NULL;\n"                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tRun until we hit EOF or a production rule triggers a return\n"     \
	"\t */\n"																  \
	"\n"                                                                      \
	"\tfor (;;) {\n"                                                          \
	"\t\t/*\n"                                                                \
	"\t\t *\tStart running the DFA\n"                                         \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tstate = 0;\n"                                                        \
	"\t\ttextSize = 0;\n"                                                     \
	"\t\t\n"                                                                  \
	"\t\tself.line = curLine;\n"                                              \
	"\t\tself.column = curColumn;\n"                                          \
	"\n"                                                                      \
	"\t\tfor (;;) {\n"                                                        \
	"\t\t\tint ch = [self input];\n"                                          \
	"\t\t\tif (ch == -1) {\n"                                                 \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tWe\'ve hit EOF. If there is no stored text, we assume\n"     \
	"\t\t\t\t *\twe\'re at the file EOF, so return EOF. Otherwise treat as\n" \
	"\t\t\t\t *\tillegal state transition.\n"                                 \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\tif (textSize == 0) return -1;\n"                                 \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tAttempt to transition to the next state\n"                     \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t charClass = CharClass[ch];\n"                             \
	"\t\t\tuint16_t newState = [self stateForClass:charClass state:state];\n" \
	"\t\t\tif (newState >= MAXSTATES) {\n"                                    \
	"\t\t\t\t/* Illegal state transition */\n"                                \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tStore the character we read, and transition to the next\n"     \
	"\t\t\t *\tstate\n"                                                       \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tstate = newState;\n"                                               \
	"\n"                                                                      \
	"\t\t\tif (textSize >= textAlloc) {\n"                                    \
	"\t\t\t\tNSInteger toFit = (textAlloc + 256) & ~255;\n"                   \
	"\t\t\t\tif (toFit < 256) toFit = 256;\n"                                 \
	"\t\t\t\tunsigned char *ptr = (unsigned char *)realloc(textBuffer, toFit);\n" \
	"\t\t\t\tif (ptr == NULL) {\n"                                            \
	"\t\t\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t\t\t}\n"                                                             \
	"\n"                                                                      \
	"\t\t\t\ttextBuffer = ptr;\n"                                             \
	"\t\t\t\ttextAlloc = toFit;\n"                                            \
	"\t\t\t}\n"                                                               \
	"\t\t\ttextBuffer[textSize++] = (char)ch;\n"                              \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tNote the current action if we have one\n"                      \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t newAction = StateActions[state];\n"                       \
	"\t\t\tif (newAction > MAXACTIONS) {\n"                                   \
	"\t\t\t\tnewAction = [self conditionalAction:newAction];\n"               \
	"\t\t\t}\n"                                                               \
	"\t\t\tif (newAction != MAXACTIONS) {\n"                                  \
	"\t\t\t\taction = newAction;\n"                                           \
	"\t\t\t\t[self mark];\n"                                                  \
	"\t\t\t}\n"                                                               \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tIf no action is set, we simply abort after setting an internal\n" \
	"\t\t *\terror state. This should never happen in a well designed lexer\n" \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tif (action == MAXACTIONS) {\n"                                       \
	"\t\t\tself.abort = @\"Illegal character sequence\";\n"                   \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tAction is set, so we rewind.\n"                                  \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\t[self reset];\n"                                                     \
	"\t\tif (textSize == 0) {\n"                                              \
	"\t\t\tself.abort = @\"No characters read in sequence\";\n"               \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tConvert text sequence into string\n"                             \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tself.text = [[NSString alloc] initWithBytes:textBuffer length:textSize encoding:NSUTF8StringEncoding];\n" \
	"\t\tself.value = self.text;\n"                                           \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tExecute action\n"                                                \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tswitch (action) {\n";

static const char *GSource6 =
	"\t\t\tdefault:\n"                                                        \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"@end\n";

/************************************************************************/
/*																		*/
/*	State writer														*/
/*																		*/
/************************************************************************/

/*	OCLexGenerator::WriteArray
 *
 *		Write an array. This simply writes the list of items to an array
 */

void OCLexGenerator::WriteArray(FILE *f, uint32_t *list, size_t len)
{
	size_t i = 0;

	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%3d",list[i]);
	}
	fprintf(f,"\n");
}

/*	OCLexGenerator::WriteStates
 *
 *		Write the states
 */

void OCLexGenerator::WriteStates(FILE *f)
{
	/*
	 *	Print the state sizes
	 */

	fprintf(f,"/************************************************************************/\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/*  Lex Transition State Tables                                         */\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/************************************************************************/\n");

	/*
	 *	Constants
	 */

	fprintf(f,"\n");
	fprintf(f,"/*\n");
	fprintf(f," *  Constants\n");
	fprintf(f," */\n\n");

	fprintf(f,"#define MAXSTATES       %lu\n",dfaStates.size());
	fprintf(f,"#define MAXCHARCLASS    %lu\n",charClasses.size());
	fprintf(f,"#define MAXACTIONS      %lu\n\n",codeRules.size());

	/*
	 *	Generate the character class list.
	 */

	uint32_t carray[256];
	size_t i,len = charClasses.size();
	for (i = 0; i < 256; ++i) carray[i] = (uint16_t)len;
	for (i = 0; i < len; ++i) {
		const OCCharSet &set = charClasses[i];
		for (int j = 0; j < 256; ++j) {
			if (set.TestCharacter((unsigned char)j)) {
				carray[j] = (uint32_t)i;
			}
		}
	}

	fprintf(f,"\n");
	fprintf(f,"//  Character classes used during parsing:\n");
	fprintf(f,"//\n");
	for (i = 0; i < len; ++i) {
		const OCCharSet &cset = charClasses[i];
		fprintf(f,"//  %zu: %s\n",i,cset.ToString().c_str());
	}
	fprintf(f,"\n");

	fprintf(f,"/*  CharClass\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps 8-bit character to character class\n");
	fprintf(f," */\n\n");
	fprintf(f,"static uint16_t CharClass[256] = {\n");
	WriteArray(f, carray, 256);
	fprintf(f,"};\n\n");

	/*
	 *	Generate state actions. This is a table which maps from a state
	 *	index to an action index. Note if this DFA state has no rule, we
	 *	land on MAXACTION. If the DFA has a conditional rule, we go to
	 *	an index greater than MAXACTION.
	 */

	fprintf(f,"/*  StateActions\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps states to actions. MAXACTION if this is not a terminal\n");
	fprintf(f," */\n\n");

	size_t alen = codeRules.size();
	uint32_t swindex = (uint32_t)alen;
	len = dfaStates.size();
	uint32_t *scratch = (uint32_t *)malloc(len * sizeof(uint32_t));
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];

		if (state.endList.size() == 0) {
			scratch[i] = (uint32_t)alen;
		} else if ((state.endList.size() == 1) &&
				   (state.endList[0].startState.unconditional())) {
			scratch[i] = state.endList[0].endRule;
		} else {
			scratch[i] = ++swindex;
		}
	}

	fprintf(f,"static uint16_t StateActions[%zu] = {\n",len);
	WriteArray(f,scratch,len);
	fprintf(f,"};\n\n");
	free(scratch);

	/*
	 *	Generate the DFA state transitions
	 */

	size_t clen = charClasses.size();
	size_t tlen = len * clen;
	scratch = (uint32_t *)malloc(tlen * sizeof(uint32_t));

	size_t ptr = 0;
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];
		for (size_t j = 0; j < clen; ++j) {
			OCCharSet &cset = charClasses[j];

			/*
			 *	Find the transition which intersects
			 */

			uint32_t newState = (uint32_t)len;

			std::vector<OCLexDFATransition>::iterator t;
			for (t = state.list.begin(); t != state.list.end(); ++t) {
				if (t->set.Contains(cset)) {
					// This transition contains our cset. Set and move on
					newState = (uint32_t)t->state;
					break;
				}
			}

			scratch[ptr++] = newState;
		}
	}

	// New format
	fprintf(f,"/*  StateMachineIA, StateMachineJA, StateMachineA\n");
	fprintf(f," *\n");
	        // 01234567890123456789012345678901234567890123456789012345678901234567890123456789
	fprintf(f," *      Lex state machine in compressed sparce row storage format. We do this\n");
	fprintf(f," *  in order to compact the resulting sparse matrix state machine so we don't\n");
	fprintf(f," *  consume as much space. Decoding the new state becomes an O(log(N)) process\n");
	fprintf(f," *  on the input character class as we use a binary search on the JA array.\n");
	fprintf(f," *\n");
	fprintf(f," *      See the article below for more information:\n");
	fprintf(f," *\n");
	fprintf(f," *      https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR.2C_CRS_or_Yale_format.29\n");
	fprintf(f," */\n\n");

	OCCompressStates comp(clen,len,scratch,(uint32_t)len);

	fprintf(f,"static uint16_t StateMachineIA[%zu] = {\n",comp.iwidth);
	WriteArray(f,comp.ia,comp.iwidth);
	fprintf(f,"};\n\n");

	fprintf(f,"static uint16_t StateMachineJA[%zu] = {\n",comp.asize);
	WriteArray(f,comp.ja,comp.asize);
	fprintf(f,"};\n\n");

	fprintf(f,"static uint16_t StateMachineA[%zu] = {\n",comp.asize);
	WriteArray(f,comp.a,comp.asize);
	fprintf(f,"};\n\n");

	free(scratch);
}

/*	OCLexGenerator::WriteActions
 *
 *		Write the actions state machine. This only writes the contents of
 *	the switch state, not the switch state itself.
 */

void OCLexGenerator::WriteActions(FILE *f)
{
	size_t i,len = codeRules.size();
	for (i = 0; i < len; ++i) {
		fprintf(f,"            case %zu:\n",i);
		fprintf(f,"                %s\n",codeRules[i].code.c_str());
		fprintf(f,"                break;\n\n");
	}
}

/************************************************************************/
/*																		*/
/*	Write start states													*/
/*																		*/
/************************************************************************/

void OCLexGenerator::WriteStarts(FILE *f)
{
	uint32_t index = (uint32_t)codeRules.size();

	fprintf(f,"/*\n");
	fprintf(f," *  For conditional states this takes an end DFA state and\n");
	fprintf(f," *  determines the proper end rule given the current start\n");
	fprintf(f," *  conditionals.\n");
	fprintf(f," */\n\n");
	fprintf(f,"- (NSInteger)conditionalAction:(NSInteger)state\n");
	fprintf(f,"{\n");
	fprintf(f,"    switch (state) {\n");
	fprintf(f,"        default:\n");
	fprintf(f,"            return MAXACTIONS;\n");

	uint32_t i,len;
	len = (uint32_t)dfaStates.size();
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];

		if ((state.endList.size() > 1) ||
			((state.endList.size() == 1) &&
				!state.endList[0].startState.unconditional())) {

			/*
			 *	This has at least one conditional rule or multiple rules.
			 *	Write them out
			 */

			bool atEnd = false;
			fprintf(f,"        case %d:\n",++index);

			uint32_t e,elen = (uint32_t)state.endList.size();
			for (e = 0; e < elen; ++e) {
				const OCLexDFAEnd &d = state.endList[e];

				if (d.startState.unconditional()) {
					fprintf(f,"            return %d;\n",d.endRule);
					atEnd = true;
					break;
				}

				bool flag = false;
				fprintf(f,"            if (");
				if (d.startState.startFlag()) {
					fprintf(f,"[self atSOL]");
					flag = true;
				}
				if (d.startState.endFlag()) {
					if (flag) {
						fprintf(f," && ");
					} else {
						flag = true;
					}
					fprintf(f,"[self atEOL]");
				}
				uint32_t m = d.startState.stateFlags(ruleStates);
				if (m) {
					if (flag) {
						fprintf(f," && ");
					}
					fprintf(f,"((%d & states) != 0)",m);
				}

				fprintf(f,") return %d;\n",d.endRule);
			}

			if (!atEnd) {
				fprintf(f,"            return MAXACTIONS;\n");
			}
		}
	}

	fprintf(f,"    }\n");
	fprintf(f,"}\n\n");
}

/************************************************************************/
/*																		*/
/*	Parser Definitions													*/
/*																		*/
/************************************************************************/

/*	OCLexGenerator::WriteOCHeader
 *
 *		This generates the standard header file, using the specified
 *	class name.
 */

void OCLexGenerator::WriteOCHeader(const char *className, const char *outName, FILE *f)
{
	fprintf(f,GHeader1,outName);

	// Header declarations
	fprintf(f,"%s\n\n",classHeader.c_str());

	fprintf(f,GHeader2,className,className);

	// Class global declarations
	fprintf(f,"%s\n\n",classGlobal.c_str());

	// Final
	fprintf(f,"%s\n",GHeader3);
}

/*	OCLexGenerator::WriteOCFile
 *
 *		This generates the various tables and writes the Objective C
 *	lex file
 */

void OCLexGenerator::WriteOCFile(const char *className, const char *outName, FILE *f)
{
	// Standard header
	fprintf(f,GSource1,outName,outName);

	// Declarations
	fprintf(f,"%s\n\n",declCode.c_str());

	// State declarations
	WriteStates(f);

	// Start class declaration
	fprintf(f,GSource2,className);

	// Insert class variables
	fprintf(f,"%s\n",classLocal.c_str());

	// Start class
	fprintf(f,GSource3,className);

	fprintf(f,"%s\n",classInit.c_str());

	fprintf(f,GSource4,className);

	// Post class declarations. We embed in our class
	fprintf(f,"%s\n\n",endCode.c_str());

	// Conditional class table
	WriteStarts(f);

	// Lexer engine
	fprintf(f,"%s",GSource5);

	// Action states
	WriteActions(f);

	// And the rest of the stuff
	fprintf(f,"%s",GSource6);
}
