//
//  OCLexGenerator.cpp
//  oclex
//
//  Created by William Woody on 7/30/17.
//  Copyright Â© 2017 Glenview Software. All rights reserved.
//

#include "OCLexGenerator.h"

/************************************************************************/
/*																		*/
/*	Standard Header														*/
/*																		*/
/************************************************************************/

static const char *GHeader =
	"/*\t%s.h\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import <Foundation/Foundation.h>\n"                                     \
	"\n"                                                                      \
	"/*\tOCFileInput\n"                                                       \
	" *\n"                                                                    \
	" *\t\tThe input file stream must correspond to this interface to read\n" \
	" *\tthe contents of a file or data object. The byte returned is from 0 to 255,\n" \
	" *\tand EOF is marked with -1.\n"                                        \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCFileInputProtocol\n"                                           \
	"#define OCFileInputProtocol\n"                                           \
	"\n"                                                                      \
	"@protocol OCFileInput <NSObject>\n"                                      \
	"- (int)readByte;\n"                                                      \
	"@end\n"                                                                  \
	"\n"                                                                      \
	"#endif\n"                                                                \
	"\n"                                                                      \
	"/*\t%s\n"                                                                \
	" *\n"                                                                    \
	" *\t\tThe standard lexical parser\n"                                     \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@interface %s : NSObject\n"                                              \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tExternal interfaces\n"                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (instancetype)initWithStream:(id<OCFileInput>)file;\n"                 \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tCurrent reader state\n"                                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@property (assign) NSInteger line;\t\t// line of last read token\n"      \
	"@property (assign) NSInteger column;\t// column of last read token\n"    \
	"@property (copy)   NSString *filename;\t// marked filename (if provided)\n" \
	"@property (copy)   NSString *text;\t\t// string of last read token\n"    \
	"@property (assign) NSString *abort;\t\t// Set to abort string if problem\n" \
	"\n"                                                                      \
	"- (NSInteger)lex;\t\t\t\t\t\t// Method to read next token\n"             \
	"\n"                                                                      \
	"@end\n";


/************************************************************************/
/*																		*/
/*	Standard Lex Body													*/
/*																		*/
/************************************************************************/

static const char *GSource1 =
	"/*\t%s.m\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#import \"%s.h\"\n"                                                      \
	"\n";

static const char *GSource2 =
	"/*\n"                                                                    \
	" *\tInternal storage\n"                                                  \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@interface %s ()\n"                                                      \
	"{\n"                                                                     \
	"\t// Read position support\n"                                            \
	"\tNSInteger curLine;\n"                                                  \
	"\tNSInteger curColumn;\n"                                                \
	"\n"                                                                      \
	"\t// Mark location support\n"                                            \
	"\tNSInteger markLine;\n"                                                 \
	"\tNSInteger markColumn;\n"                                               \
	"\n"                                                                      \
	"\t// Mark buffer storage\n"                                              \
	"\tBOOL isMarked;\t\t\t\t\t\t\t// yes if we have mark set\n"              \
	"\tunsigned char *markBuffer;\t\t\t\t// mark buffer\n"                    \
	"\tNSInteger markSize;\t\t\t\t\t\t// bytes stored in buffer\n"            \
	"\tNSInteger markAlloc;\t\t\t\t\t// capacity of buffer\n"                 \
	"\n"                                                                      \
	"\t// Read cache\n"                                                       \
	"\tunsigned char *readBuffer;\t\t\t\t// read cache buffer\n"              \
	"\tNSInteger readPos;\t\t\t\t\t\t// Read position\n"                      \
	"\tNSInteger readSize;\t\t\t\t\t\t// size of data in read buffer\n"       \
	"\tNSInteger readAlloc;\t\t\t\t\t// Capacity of read cache\n"             \
	"\n"                                                                      \
	"\t// Text read buffer\n"                                                 \
	"\tunsigned char *textBuffer;\t\t\t\t// text cache for reading buffer\n"  \
	"\tNSInteger textMarkSize;\n"                                             \
	"\tNSInteger textSize;\n"                                                 \
	"\tNSInteger textAlloc;\n"                                                \
	"}\n"                                                                     \
	"\n"                                                                      \
	"@property (strong) id<OCFileInput> file;\n";

static const char *GSource3 =
	"@end\n"                                                                  \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tClass lexer\n"                                                       \
	" */\n"                                                                   \
	"\n"                                                                      \
	"@implementation %s\n"                                                    \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInstantiate parser.\n"                                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (instancetype)initWithStream:(id<OCFileInput>)file\n"                  \
	"{\n"                                                                     \
	"\tif (nil != (self = [super init])) {\n"                                 \
	"\t\tself.file = file;\n"                                                 \
	"\n"                                                                      \
	"\t\tisMarked = NO;\n"                                                    \
	"\t\tmarkSize = 0;\n"                                                     \
	"\t\tmarkAlloc = 256;\n"                                                  \
	"\t\tmarkBuffer = (unsigned char *)malloc(markAlloc);\n"                  \
	"\n"                                                                      \
	"\t\treadPos = 0;\n"                                                      \
	"\t\treadSize = 0;\n"                                                     \
	"\t\treadAlloc = 256;\n"                                                  \
	"\t\treadBuffer = (unsigned char *)malloc(readAlloc);\n"                  \
	"\n"                                                                      \
	"\t\ttextMarkSize = 0;\n"                                                 \
	"\t\ttextSize = 0;\n"                                                     \
	"\t\ttextAlloc = 256;\n"                                                  \
	"\t\ttextBuffer = (unsigned char *)malloc(textAlloc);\n"                  \
	"\t}\n"                                                                   \
	"\treturn self;\n"                                                        \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tFree internal storage\n"                                             \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)dealloc\n"                                                       \
	"{\n"                                                                     \
	"\tif (markBuffer) free(markBuffer);\n"                                   \
	"\tif (readBuffer) free(readBuffer);\n"                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal read backtrack support. We implement the internal methods\n" \
	" *\tfor mark, unmark and reset to note the current file position. This is\n" \
	" *\tused by the lexer to unwind the read queue if we overread the number\n" \
	" *\tof characters during parsing\n"                                      \
	" *\n"                                                                    \
	" *\tIn essence, as we execute the DFA while we read characters, when we\n" \
	" *\tfind an end state, we mark the stream. Then we continue to read until\n" \
	" *\twe reach an error--at which point we rewind back to the mark location.\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tmark: note that we should cache characters being read so we can rewind\n" \
	" *\tto this location in the future\n"                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)mark\n"                                                          \
	"{\n"                                                                     \
	"\t/*\n"                                                                  \
	"\t *\tStore the current file location and enable marking. This has the side\n" \
	"\t *\teffect of flushing any previous mark buffer\n"                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tmarkLine = curLine;\n"                                                 \
	"\tmarkColumn = curColumn;\n"                                             \
	"\ttextMarkSize = textSize;\n"                                            \
	"\n"                                                                      \
	"\tisMarked = YES;\n"                                                     \
	"\tmarkSize = 0;\n"                                                       \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tReset: reset the buffer positions\n"                                 \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (void)reset\n"                                                         \
	"{\n"                                                                     \
	"\tif (!isMarked) return;\t// not marked, nothing to do.\n"               \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReset to the marked position. We maintain two mutable data objects,\n" \
	"\t *\tone which stores the data we\'re reading from (if any), and one which\n" \
	"\t *\tstores the marked data.\n"                                         \
	"\t *\n"                                                                  \
	"\t *\tReset does two things: it prepends the read buffer with the data we\n" \
	"\t *\tstored during the mark phase, and we clear the mark flag.\n"       \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize + readSize - readPos > readAlloc) {\n"                    \
	"\t\t/*\n"                                                                \
	"\t\t *\tResize to fit\n"                                                 \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tNSInteger toFit = markSize + readSize - readPos;\n"                  \
	"\t\ttoFit = (toFit + 255) & ~255;\t// align to 256 byte boundary\n"      \
	"\t\tif (toFit < 0) toFit = 256;\n"                                       \
	"\n"                                                                      \
	"\t\tunsigned char *ptr = (unsigned char *)realloc(readBuffer, toFit);\n" \
	"\t\tif (ptr == NULL) {\n"                                                \
	"\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\treadBuffer = ptr;\n"                                                 \
	"\t\treadAlloc = toFit;\n"                                                \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the contents of the read buffer to a location above where the\n" \
	"\t *\tmark queue will go\n"                                              \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tmemmove(markSize + readBuffer, readPos + readBuffer, readSize - readPos);\n" \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the marked data\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize > 0) {\n"                                                 \
	"\t\tmemmove(readBuffer, markBuffer, markSize);\n"                        \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the read buffer settings\n"                                 \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treadSize = markSize + readSize - readPos;\n"                           \
	"\treadPos = 0;\n"                                                        \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tClear the mark\n"                                                  \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tisMarked = NO;\n"                                                      \
	"\tmarkSize = 0;\n"                                                       \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the file position\n"                                        \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tcurLine = markLine;\n"                                                 \
	"\tcurColumn = markColumn;\n"                                             \
	"\ttextSize = textMarkSize;\n"                                            \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead input stream.\n"                                                \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (int)input\n"                                                          \
	"{\n"                                                                     \
	"\tint ch;\n"                                                             \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tLow level: read, if from marked buffer\n"                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tch = readBuffer[readPos++];\n"                                       \
	"\t} else {\n"                                                            \
	"\t\tch = [self.file readByte];\n"                                        \
	"\n"                                                                      \
	"\t\tif (ch == -1) return -1;\t\t// At EOF; immediate return.\n"          \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate file position\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (ch == \'\\n\') {\n"                                                \
	"\t\tcurColumn = 0;\n"                                                    \
	"\t\t++curLine;\n"                                                        \
	"\t} else {\n"                                                            \
	"\t\t++curColumn;\n"                                                      \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tHandle mark\n"                                                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (isMarked) {\n"                                                     \
	"\t\tif (markSize >= markAlloc) {\n"                                      \
	"\t\t\tNSInteger toFit = (markAlloc + 256) & ~255;\n"                     \
	"\t\t\tif (toFit < 256) toFit = 256;\n"                                   \
	"\t\t\tunsigned char *ptr = (unsigned char *)realloc(markBuffer, toFit);\n" \
	"\t\t\tif (ptr == NULL) {\n"                                              \
	"\t\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\tmarkBuffer = ptr;\n"                                               \
	"\t\t\tmarkAlloc = toFit;\n"                                              \
	"\t\t}\n"                                                                 \
	"\t\tmarkBuffer[markSize++] = (unsigned char)ch;\n"                       \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReturn read character.\n"                                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treturn ch;\n"                                                          \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal methods declared within the Lex file\n"                     \
	" */\n";

static const char *GSource4 =
	"/*\n"                                                                    \
	" *\tLex interpreter. This runs the state machine until we find something\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"- (NSInteger)lex\n"                                                      \
	"{\n"                                                                     \
	"\tuint16_t state;\n"                                                     \
	"\tuint16_t action = MAXACTIONS;\n"                                       \
	"\n"                                                                      \
	"\tself.abort = NULL;\n"                                                  \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tRun until we hit EOF\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tfor (;;) {\n"                                                          \
	"\t\t/*\n"                                                                \
	"\t\t *\tStart running the DFA\n"                                         \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tstate = 0;\n"                                                        \
	"\t\ttextSize = 0;\n"                                                     \
	"\n"                                                                      \
	"\t\tfor (;;) {\n"                                                        \
	"\t\t\tint ch = [self input];\n"                                          \
	"\t\t\tif (ch == -1) {\n"                                                 \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tWe\'ve hit EOF. If there is no stored text, we assume\n"     \
	"\t\t\t\t *\twe\'re at the file EOF, so return EOF. Otherwise treat as\n" \
	"\t\t\t\t *\tillegal state transition.\n"                                 \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\tif (textSize == 0) return -1;\n"                                 \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tAttempt to transition to the next state\n"                     \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t charClass = CharClass[ch];\n"                             \
	"\t\t\tuint16_t newState = StateMachine[charClass + MAXCHARCLASS * state];\n" \
	"\t\t\tif (newState >= MAXSTATES) {\n"                                    \
	"\t\t\t\t/* Illegal state transition */\n"                                \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tStore the character we read, and transition to the next\n"     \
	"\t\t\t *\tstate\n"                                                       \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tstate = newState;\n"                                               \
	"\n"                                                                      \
	"\t\t\tif (textSize >= textAlloc) {\n"                                    \
	"\t\t\t\tNSInteger toFit = (textAlloc + 256) & ~255;\n"                   \
	"\t\t\t\tif (toFit < 256) toFit = 256;\n"                                 \
	"\t\t\t\tunsigned char *ptr = (unsigned char *)realloc(textBuffer, toFit);\n" \
	"\t\t\t\tif (ptr == NULL) {\n"                                            \
	"\t\t\t\t\t[NSException raise:NSMallocException format:@\"Out of memory\"];\n" \
	"\t\t\t\t}\n"                                                             \
	"\n"                                                                      \
	"\t\t\t\ttextBuffer = ptr;\n"                                             \
	"\t\t\t\ttextAlloc = toFit;\n"                                            \
	"\t\t\t}\n"                                                               \
	"\t\t\ttextBuffer[textSize++] = (char)ch;\n"                              \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tNote the current action if we have one\n"                      \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t newAction = StateActions[state];\n"                       \
	"\t\t\tif (newAction != MAXACTIONS) {\n"                                  \
	"\t\t\t\taction = newAction;\t\t\t/* Note action */\n"                    \
	"\t\t\t\t[self mark];\t\t\t\t/* Mark location for rewind */\n"            \
	"\t\t\t}\n"                                                               \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tWhen we reach here we read a character that is illegal.\n"       \
	"\t\t *\tThis means we rewind to the last successfully read character,\n" \
	"\t\t *\tand execute the\n"                                               \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tIf no action is set, we simply abort after setting an internal\n" \
	"\t\t *\terror state. This should never happen in a well designed lexer\n" \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tif (action == MAXACTIONS) {\n"                                       \
	"\t\t\tself.abort = @\"Illegal character sequence\";\n"                   \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tAction is set, so we rewind.\n"                                  \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\t[self reset];\n"                                                     \
	"\t\tif (textSize == 0) {\n"                                              \
	"\t\t\tself.abort = @\"No characters read in sequence\";\n"               \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tConvert text sequence into string\n"                             \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tself.text = [[NSString alloc] initWithBytes:textBuffer length:textSize encoding:NSUTF8StringEncoding];\n" \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tExecute action\n"                                                \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tswitch (action) {\n";

static const char *GSource5 =
	"\t\t\tdefault:\n"                                                        \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"@end\n";

/************************************************************************/
/*																		*/
/*	State writer														*/
/*																		*/
/************************************************************************/

/*	OCLexGenerator::WriteArray
 *
 *		Write an array. This simply writes the list of items to an array
 */

void OCLexGenerator::WriteArray(FILE *f, uint16_t *list, size_t len)
{
	size_t i = 0;

	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%3d",list[i]);
	}
	fprintf(f,"\n");
}

/*	OCLexGenerator::WriteStates
 *
 *		Write the states
 */

void OCLexGenerator::WriteStates(FILE *f)
{
	/*
	 *	Print the state sizes
	 */

	fprintf(f,"/************************************************************************/\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/*  Lex Transition State Tables                                         */\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/************************************************************************/\n");

	/*
	 *	Constants
	 */

	fprintf(f,"\n");
	fprintf(f,"/*\n");
	fprintf(f," *  Constants\n");
	fprintf(f," */\n\n");

	fprintf(f,"#define MAXSTATES       %lu\n",dfaStates.size());
	fprintf(f,"#define MAXCHARCLASS    %lu\n",charClasses.size());
	fprintf(f,"#define MAXACTIONS      %lu\n\n",codeRules.size());

	/*
	 *	Generate the character class list.
	 */

	uint16_t carray[256];
	size_t i,len = charClasses.size();
	for (i = 0; i < 256; ++i) carray[i] = (uint16_t)len;
	for (i = 0; i < len; ++i) {
		const OCCharSet &set = charClasses[i];
		for (int j = 0; j < 256; ++j) {
			if (set.TestCharacter((unsigned char)j)) {
				carray[j] = i;
			}
		}
	}

	fprintf(f,"\n");
	fprintf(f,"//  Character classes used during parsing:\n");
	fprintf(f,"//\n");
	for (i = 0; i < len; ++i) {
		const OCCharSet &cset = charClasses[i];
		fprintf(f,"//  %zu: %s\n",i,cset.ToString().c_str());
	}
	fprintf(f,"\n");

	fprintf(f,"/*  CharClass\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps 8-bit character to character class\n");
	fprintf(f," */\n\n");
	fprintf(f,"static uint16_t CharClass[256] = {\n");
	WriteArray(f, carray, 256);
	fprintf(f,"};\n\n");

	/*
	 *	Generate state actions. This is a table which maps from a state
	 *	index to an action index
	 */

	fprintf(f,"/*  StateActions\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps states to actions. MAXACTION if this is not a terminal\n");
	fprintf(f," */\n\n");

	size_t alen = codeRules.size();
	len = dfaStates.size();
	uint16_t *scratch = (uint16_t *)malloc(len * sizeof(uint16_t));
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];
		scratch[i] = state.end ? state.endRule : alen;
	}

	fprintf(f,"static uint16_t StateActions[%zu] = {\n",len);
	WriteArray(f,scratch,len);
	fprintf(f,"};\n\n");

	/*
	 *	Generate the DFA state transitions
	 */

	size_t clen = charClasses.size();
	size_t tlen = len * clen;
	scratch = (uint16_t *)malloc(tlen * sizeof(uint16_t));

	size_t ptr = 0;
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];
		for (size_t j = 0; j < clen; ++j) {
			OCCharSet &cset = charClasses[j];

			/*
			 *	Find the transition which intersects
			 */

			uint16_t newState = (uint16_t)len;

			std::vector<OCLexDFATransition>::iterator t;
			for (t = state.list.begin(); t != state.list.end(); ++t) {
				if (t->set.Contains(cset)) {
					// This transition contains our cset. Set and move on
					newState = (uint16_t)t->state;
					break;
				}
			}

			scratch[ptr++] = newState;
		}
	}

	fprintf(f,"/*  StateMachine\n");
	fprintf(f," *\n");
	fprintf(f," *      Lex state machine. Each item indicates the transition from\n");
	fprintf(f," *  a character set and the state to a new state. The new state is\n");
	fprintf(f," *  MAXSTATES if the transition is illegal.\n");
	fprintf(f," *\n");
	fprintf(f," *      The index is charClass + state * MAXCHARCLASS\n");
	fprintf(f," */\n\n");
	fprintf(f,"static uint16_t StateMachine[%zu] = {\n",tlen);
	WriteArray(f,scratch,tlen);
	fprintf(f,"};\n\n");

	free(scratch);
}

/*	OCLexGenerator::WriteActions
 *
 *		Write the actions state machine. This only writes the contents of
 *	the switch state, not the switch state itself.
 */

void OCLexGenerator::WriteActions(FILE *f)
{
	size_t i,len = codeRules.size();
	for (i = 0; i < len; ++i) {
		fprintf(f,"            case %zu:\n",i);
		fprintf(f,"                %s\n",codeRules[i].c_str());
		fprintf(f,"                break;\n\n");
	}
}

/************************************************************************/
/*																		*/
/*	Parser Definitions													*/
/*																		*/
/************************************************************************/

/*	OCLexGenerator::WriteOCHeader
 *
 *		This generates the standard header file, using the specified
 *	class name.
 */

void OCLexGenerator::WriteOCHeader(const char *className, FILE *f)
{
	fprintf(f,GHeader,className,className,className);
}

/*	OCLexGenerator::WriteOCFile
 *
 *		This generates the various tables and writes the Objective C
 *	lex file
 */

void OCLexGenerator::WriteOCFile(const char *className, FILE *f)
{
	// Standard header
	fprintf(f,GSource1,className,className);

	// Declarations
	fprintf(f,"%s\n\n",declCode.c_str());

	// State declarations
	WriteStates(f);

	// Start class declaration
	fprintf(f,GSource2,className);

	// Insert class variables
	fprintf(f,"%s\n\n",classDecl.c_str());

	// Start class
	fprintf(f,GSource3,className);

	// Post class declarations. We embed in our class
	fprintf(f,"%s\n\n",endCode.c_str());

	// Lexer engine
	fprintf(f,"%s",GSource4);

	// Action states
	WriteActions(f);

	// And the rest of the stuff
	fprintf(f,"%s",GSource5);
}
