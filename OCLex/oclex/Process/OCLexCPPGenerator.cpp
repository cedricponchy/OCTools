//
//  OCLexCPPGenerator.cpp
//  oclex
//
//  Created by William Woody on 4/12/18.
//  Copyright Â© 2018 Glenview Software. All rights reserved.
//

#include "OCLexCPPGenerator.h"

/************************************************************************/
/*																		*/
/*	Standard Header														*/
/*																		*/
/************************************************************************/

// 1
static const char *GHeader1 =
	"/*\t%s.h\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#include <stdint.h>\n"                                                   \
	"#include <string>\n"                                                     \
	"\n";

// 4
static const char *GHeader2 =
	"/*\tOCFileInput\n"                                                       \
	" *\n"                                                                    \
	" *\t\tThe input file stream must correspond to this interface to read\n" \
	" *\tthe contents of a file or data object. The byte returned is from 0 to 255,\n" \
	" *\tand EOF is marked with -1.\n"                                        \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCFileInputProtocolC\n"                                          \
	"#define OCFileInputProtocolC\n"                                          \
	"\n"                                                                      \
	"class OCFileInput\n"                                                     \
	"{\n"                                                                     \
	"\tpublic:\n"                                                             \
	"\t\tvirtual int readByte() = 0;\n"                                       \
	"\t\tvirtual int peekByte() = 0;\n"                                       \
	"};\n"                                                                    \
	"\n"                                                                      \
	"#endif\n"                                                                \
	"\n"                                                                      \
	"/*\tOCLexInput\n"                                                        \
	" *\n"                                                                    \
	" *\t\tThe protocol for our lex reader file that the lex stream must\n"   \
	" *\tprovide. This is the same as the protocol generated as part of the OCYacc\n" \
	" *\toutput, and allows us to glue the Lexer and Parser together.\n"      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#ifndef OCLexInputProtocolC\n"                                           \
	"#define OCLexInputProtocolC\n"                                           \
	"\n"                                                                      \
	"class OCLexInput\n"                                                      \
	"{\n"                                                                     \
	"\tpublic:\n"                                                             \
	"\t\tvirtual int32_t line() = 0;\n"                                       \
	"\t\tvirtual int32_t column() = 0;\n"                                     \
	"\t\tvirtual std::string filename() = 0;\n"                               \
	"\t\tvirtual std::string text() = 0;\n"                                   \
	"\t\tvirtual std::string abort() = 0;\n"                                  \
	"\n"                                                                      \
	"\t\tvirtual int32_t lex() = 0;\n"                                        \
	"\t\tvirtual void *value() = 0;\t\t\t// Arbitrary type\n"                 \
	"};\n"                                                                    \
	"\n"                                                                      \
	"#endif\n"                                                                \
	"\n"                                                                      \
	"/*\t%s\n"                                                                \
	" *\n"                                                                    \
	" *\t\tThe generated lexical parser\n"                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"class %s : public OCLexInput\n"                                          \
	"{\n"                                                                     \
	"\tpublic:\n"                                                             \
	"\t\t%s(OCFileInput *file);\n"                                            \
	"\t\t~%s(void);\n"                                                        \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tCurrent reader state\n"                                          \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tint32_t line()\n"                                                    \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fLine;\n"                                                 \
	"\t\t\t}\n"                                                               \
	"\t\tint32_t column()\n"                                                  \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fColumn;\n"                                               \
	"\t\t\t}\n"                                                               \
	"\t\tstd::string filename()\n"                                            \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fFileName;\n"                                             \
	"\t\t\t}\n"                                                               \
	"\t\tstd::string text()\n"                                                \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fText;\n"                                                 \
	"\t\t\t}\n"                                                               \
	"\t\tstd::string abort()\n"                                               \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fAbort;\n"                                                \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\tvoid *value()\n"                                                     \
	"\t\t\t{\n"                                                               \
	"\t\t\t\treturn fValue;\n"                                                \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\tvoid setFile(std::string &file, int32_t line);\n"                    \
	"\t\tvoid setLine(int32_t line);\n"                                       \
	"\t\tint32_t lex();\t\t\t\t\t\t// Method to read next token\n";

// 0
static const char *GHeader3 =
	"\tprivate:\n"                                                            \
	"\t\t// Files\n"                                                          \
	"\t\tOCFileInput *file;\n"                                                \
	"\n"                                                                      \
	"\t\t// Read position support\n"                                          \
	"\t\tint32_t curLine;\n"                                                  \
	"\t\tint32_t curColumn;\n"                                                \
	"\n"                                                                      \
	"\t\t// Mark location support\n"                                          \
	"\t\tint32_t markLine;\n"                                                 \
	"\t\tint32_t markColumn;\n"                                               \
	"\n"                                                                      \
	"\t\t// Mark buffer storage\n"                                            \
	"\t\tbool isMarked;\t\t\t\t\t\t// yes if we have mark set\n"              \
	"\t\tunsigned char *markBuffer;\t\t\t// mark buffer\n"                    \
	"\t\tint32_t markSize;\t\t\t\t\t// bytes stored in buffer\n"              \
	"\t\tint32_t markAlloc;\t\t\t\t\t// capacity of buffer\n"                 \
	"\n"                                                                      \
	"\t\t// Read cache\n"                                                     \
	"\t\tunsigned char *readBuffer;\t\t\t// read cache buffer\n"              \
	"\t\tint32_t readPos;\t\t\t\t\t// Read position\n"                        \
	"\t\tint32_t readSize;\t\t\t\t\t// size of data in read buffer\n"         \
	"\t\tint32_t readAlloc;\t\t\t\t\t// Capacity of read cache\n"             \
	"\n"                                                                      \
	"\t\t// Text read buffer\n"                                               \
	"\t\tunsigned char *textBuffer;\t\t\t// text cache for reading buffer\n"  \
	"\t\tint32_t textMarkSize;\n"                                             \
	"\t\tint32_t textSize;\n"                                                 \
	"\t\tint32_t textAlloc;\n"                                                \
	"\n"                                                                      \
	"\t\t// State flags\n"                                                    \
	"\t\tuint64_t  states;\n"                                                 \
	"\n"                                                                      \
	"\t\t// File state\n"                                                     \
	"\t\tint32_t fLine;\n"                                                    \
	"\t\tint32_t fColumn;\n"                                                  \
	"\t\tstd::string fFileName;\n"                                            \
	"\t\tstd::string fText;\n"                                                \
	"\t\tstd::string fAbort;\n"                                               \
	"\t\tvoid *fValue;\n"                                                     \
	"\n"                                                                      \
	"\t\t// Internal Methods\n"                                               \
	"\t\tvoid mark(void);\n"                                                  \
	"\t\tvoid reset(void);\n"                                                 \
	"\t\tint input(void);\n"                                                  \
	"\t\tbool atEOL(void);\n"                                                 \
	"\t\tbool atSOL(void);\n"                                                 \
	"\t\tuint16_t stateForClass(uint16_t charClass, uint16_t state);\n"       \
	"\t\tuint16_t conditionalAction(uint16_t state);\n";

// 0
static const char *GHeader4 =
	"};\n";

/************************************************************************/
/*																		*/
/*	Standard Lex Body													*/
/*																		*/
/************************************************************************/

// 2
static const char *GSource1 =
	"/*\t%s.cpp\n"                                                              \
	" *\n"                                                                    \
	" *\t\tThis file was automatically generated by OCLex, part of the OCTools\n" \
	" *\tsuite available at:\n"                                               \
	" *\n"                                                                    \
	" *\t\thttps://github.com/w3woody/OCTools\n"                              \
	" */\n"                                                                   \
	"\n"                                                                      \
	"#include \"%s.h\"\n"                                                     \
	"#include <stdlib.h>\n"                                                   \
	"#include <new>\n"                                                        \
	"\n";

// 4
static const char *GSource2 =
	"/************************************************************************/\n" \
	"/*                                                                      */\n" \
	"/*  Construction/Destruction                                            */\n" \
	"/*                                                                      */\n" \
	"/************************************************************************/\n" \
	"\n"                                                                      \
	"/*\t%s::%s\n"                                                            \
	" *\n"                                                                    \
	" *\t\tConstructor\n"                                                     \
	" */\n"                                                                   \
	"\n"                                                                      \
	"%s::%s(OCFileInput *f)\n"                                                \
	"{\n"                                                                     \
	"\tfile = f;\n"                                                           \
	"\n"                                                                      \
	"\tisMarked = false;\n"                                                   \
	"\n"                                                                      \
	"\tmarkSize = 0;\n"                                                       \
	"\tmarkAlloc = 256;\n"                                                    \
	"\tmarkBuffer = (unsigned char *)malloc(markAlloc);\n"                    \
	"\n"                                                                      \
	"\treadPos = 0;\n"                                                        \
	"\treadSize = 0;\n"                                                       \
	"\treadAlloc = 256;\n"                                                    \
	"\treadBuffer = (unsigned char *)malloc(readAlloc);\n"                    \
	"\n"                                                                      \
	"\ttextMarkSize = 0;\n"                                                   \
	"\ttextSize = 0;\n"                                                       \
	"\ttextAlloc = 256;\n"                                                    \
	"\ttextBuffer = (unsigned char *)malloc(textAlloc);\n"                    \
	"\n"                                                                      \
	"\tstates = 0;\n";

// 14
static const char *GSource3 =
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\t%s::~%s\n"                                                           \
	" *\n"                                                                    \
	" *\t\tDestructor\n"                                                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"%s::~%s(void)\n"                                                         \
	"{\n"                                                                     \
	"\tif (markBuffer) free(markBuffer);\n"                                   \
	"\tif (readBuffer) free(readBuffer);\n"                                   \
	"\tif (textBuffer) free(textBuffer);\n"                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal read backtrack support. We implement the internal methods\n" \
	" *\tfor mark, unmark and reset to note the current file position. This is\n" \
	" *\tused by the lexer to unwind the read queue if we overread the number\n" \
	" *\tof characters during parsing\n"                                      \
	" *\n"                                                                    \
	" *\tIn essence, as we execute the DFA while we read characters, when we\n" \
	" *\tfind an end state, we mark the stream. Then we continue to read until\n" \
	" *\twe reach an error--at which point we rewind back to the mark location.\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"/*\t%s::mark\n"                                                          \
	" *\n"                                                                    \
	" *\t\tMark: note that we should cache characters being read so we can rewind\n" \
	" *\tto this location in the future\n"                                    \
	" */\n"                                                                   \
	"\n"                                                                      \
	"void %s::mark(void)\n"                                                   \
	"{\n"                                                                     \
	"\t/*\n"                                                                  \
	"\t *\tStore the current file location and enable marking. This has the side\n" \
	"\t *\teffect of flushing any previous mark buffer\n"                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tmarkLine = curLine;\n"                                                 \
	"\tmarkColumn = curColumn;\n"                                             \
	"\ttextMarkSize = textSize;\n"                                            \
	"\n"                                                                      \
	"\tisMarked = true;\n"                                                    \
	"\tmarkSize = 0;\n"                                                       \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\t%s::reset\n"                                                         \
	" *\n"                                                                    \
	" *\t\tReset: reset the buffer positions\n"                               \
	" */\n"                                                                   \
	"\n"                                                                      \
	"void %s::reset(void)\n"                                                  \
	"{\n"                                                                     \
	"\tif (!isMarked) return;\t// not marked, nothing to do.\n"               \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReset to the marked position. We maintain two mutable data objects,\n" \
	"\t *\tone which stores the data we\'re reading from (if any), and one which\n" \
	"\t *\tstores the marked data.\n"                                         \
	"\t *\n"                                                                  \
	"\t *\tReset does two things: it prepends the read buffer with the data we\n" \
	"\t *\tstored during the mark phase, and we clear the mark flag.\n"       \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize + readSize - readPos > readAlloc) {\n"                    \
	"\t\t/*\n"                                                                \
	"\t\t *\tResize to fit\n"                                                 \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tint32_t toFit = markSize + readSize - readPos;\n"                    \
	"\t\ttoFit = (toFit + 255) & ~255;\t// align to 256 byte boundary\n"      \
	"\t\tif (toFit < 0) toFit = 256;\n"                                       \
	"\n"                                                                      \
	"\t\tunsigned char *ptr = (unsigned char *)realloc(readBuffer, toFit);\n" \
	"\t\tif (ptr == NULL) {\n"                                                \
	"\t\t\tthrow std::bad_alloc();\n"                                         \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\treadBuffer = ptr;\n"                                                 \
	"\t\treadAlloc = toFit;\n"                                                \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the contents of the read buffer to a location above where the\n" \
	"\t *\tmark queue will go\n"                                              \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tmemmove(markSize + readBuffer, readPos + readBuffer, readSize - readPos);\n" \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tMove the marked data\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (markSize > 0) {\n"                                                 \
	"\t\tmemmove(readBuffer, markBuffer, markSize);\n"                        \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the read buffer settings\n"                                 \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treadSize = markSize + readSize - readPos;\n"                           \
	"\treadPos = 0;\n"                                                        \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tClear the mark\n"                                                  \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tisMarked = false;\n"                                                   \
	"\tmarkSize = 0;\n"                                                       \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate the file position\n"                                        \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tcurLine = markLine;\n"                                                 \
	"\tcurColumn = markColumn;\n"                                             \
	"\ttextSize = textMarkSize;\n"                                            \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead input stream.\n"                                                \
	" */\n"                                                                   \
	"\n"                                                                      \
	"int %s::input(void)\n"                                                   \
	"{\n"                                                                     \
	"\tint ch;\n"                                                             \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tLow level: read, if from marked buffer\n"                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tch = readBuffer[readPos++];\n"                                       \
	"\t} else {\n"                                                            \
	"\t\tch = file->readByte();\n"                                            \
	"\n"                                                                      \
	"\t\tif (ch == -1) return -1;\t\t// At EOF; immediate return.\n"          \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tUpdate file position\n"                                            \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (ch == \'\\n\') {\n"                                                \
	"\t\tcurColumn = 0;\n"                                                    \
	"\t\t++curLine;\n"                                                        \
	"\t} else {\n"                                                            \
	"\t\t++curColumn;\n"                                                      \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tHandle mark\n"                                                     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tif (isMarked) {\n"                                                     \
	"\t\tif (markSize >= markAlloc) {\n"                                      \
	"\t\t\tint32_t toFit = (markAlloc + 256) & ~255;\n"                       \
	"\t\t\tif (toFit < 256) toFit = 256;\n"                                   \
	"\t\t\tunsigned char *ptr = (unsigned char *)realloc(markBuffer, toFit);\n" \
	"\t\t\tif (ptr == NULL) {\n"                                              \
	"\t\t\t\tthrow std::bad_alloc();\n"                                       \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\tmarkBuffer = ptr;\n"                                               \
	"\t\t\tmarkAlloc = toFit;\n"                                              \
	"\t\t}\n"                                                                 \
	"\t\tmarkBuffer[markSize++] = (unsigned char)ch;\n"                       \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tReturn read character.\n"                                          \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\treturn ch;\n"                                                          \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead ahead to determine if we\'re at the EOL\n"                      \
	" */\n"                                                                   \
	"\n"                                                                      \
	"bool %s::atEOL()\n"                                                      \
	"{\n"                                                                     \
	"\tint ch;\n"                                                             \
	"\n"                                                                      \
	"\tif (readPos < readSize) {\n"                                           \
	"\t\tch = readBuffer[readPos];\n"                                         \
	"\t} else {\n"                                                            \
	"\t\tch = file->peekByte();\n"                                            \
	"\t}\n"                                                                   \
	"\n"                                                                      \
	"\tif ((ch == -1) || (ch == \'\\n\')) return true;\n"                     \
	"\treturn false;\n"                                                       \
	"}\n"                                                                     \
	"\n"                                                                      \
	"bool %s::atSOL()\n"                                                      \
	"{\n"                                                                     \
	"\treturn fColumn == 0;\n"                                                \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tRead the state for the class/state combination. Decodes the sparce\n" \
	" *\tmatrix that is compressed in StateMachineIA/JA/A above. If the\n"    \
	" *\tentry is not found, returns MAXSTATES. This is the same as the lookup\n" \
	" *\tStateMachine[class][state] if the StateMachine sparse array was\n"   \
	" *\tunrolled\n"                                                          \
	" */\n"                                                                   \
	"\n"                                                                      \
	"uint16_t %s::stateForClass(uint16_t charClass, uint16_t state)\n"        \
	"{\n"                                                                     \
	"\tsize_t min,max,mid;\n"                                                 \
	"\n"                                                                      \
	"\t/* Find range */\n"                                                    \
	"\tmin = StateMachineIA[state];\n"                                        \
	"\tmax = StateMachineIA[state+1];\n"                                      \
	"\n"                                                                      \
	"\t/* Binary search for value in ja */\n"                                 \
	"\twhile (min < max) {\n"                                                 \
	"\t\tmid = (min + max)/2;\n"                                              \
	"\t\tuint16_t j = StateMachineJA[mid];\n"                                 \
	"\t\tif (charClass == j) {\n"                                             \
	"\t\t\treturn StateMachineA[mid];\n"                                      \
	"\t\t} else if (charClass < j) {\n"                                       \
	"\t\t\tmax = mid;\n"                                                      \
	"\t\t} else {\n"                                                          \
	"\t\t\tmin = mid+1;\n"                                                    \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"\treturn MAXSTATES;\n"                                                   \
	"}\n"                                                                     \
	"\n"                                                                      \
	"void %s::setFile(std::string &file, int32_t line)\n"                     \
	"{\n"                                                                     \
	"\tfFileName = file;\n"                                                   \
	"\tcurLine = line;\n"                                                     \
	"}\n"                                                                     \
	"\n"                                                                      \
	"void %s::setLine(int32_t line)\n"                                        \
	"{\n"                                                                     \
	"\tcurLine = line;\n"                                                     \
	"}\n"                                                                     \
	"\n"                                                                      \
	"/*\n"                                                                    \
	" *\tInternal methods declared within the Lex file\n"                     \
	" */\n"                                                                   \
	"\n";

// 2
static const char *GSource4 =
	"/*\t%s::lex\n"                                                           \
	" *\n"                                                                    \
	" *\t\tLex interpreter. THis runs the state machine until we find something\n" \
	" */\n"                                                                   \
	"\n"                                                                      \
	"int32_t %s::lex(void)\n"                                                 \
	"{\n"                                                                     \
	"\tuint16_t state;\n"                                                     \
	"\tuint16_t action = MAXACTIONS;\n"                                       \
	"\n"                                                                      \
	"\tfValue = NULL;\n"                                                      \
	"\n"                                                                      \
	"\t/*\n"                                                                  \
	"\t *\tRun until we hit EOF or a production rule triggers a return\n"     \
	"\t */\n"                                                                 \
	"\n"                                                                      \
	"\tfor (;;) {\n"                                                          \
	"\t\t/*\n"                                                                \
	"\t\t *\tStart running the DFA\n"                                         \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tstate = 0;\n"                                                        \
	"\t\ttextSize = 0;\n"                                                     \
	"\n"                                                                      \
	"\t\tfLine = curLine;\n"                                                  \
	"\t\tfColumn = curColumn;\n"                                              \
	"\n"                                                                      \
	"\t\tfor (;;) {\n"                                                        \
	"\t\t\tint ch = input();\n"                                               \
	"\t\t\tif (ch == -1) {\n"                                                 \
	"\t\t\t\t/*\n"                                                            \
	"\t\t\t\t *\tWe\'ve hit EOF. If there is no stored text, we assume\n"     \
	"\t\t\t\t *\twe\'re at the file EOF, so return EOF. Otherwise treat as\n" \
	"\t\t\t\t *\tillegal state transition.\n"                                 \
	"\t\t\t\t */\n"                                                           \
	"\n"                                                                      \
	"\t\t\t\tif (textSize == 0) return -1;\n"                                 \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tAttempt to transition to the next state\n"                     \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t charClass = CharClass[ch];\n"                             \
	"\t\t\tuint16_t newState = stateForClass(charClass, state);\n"            \
	"\t\t\tif (newState >= MAXSTATES) {\n"                                    \
	"\t\t\t\t/* Illegal state transition */\n"                                \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t\t}\n"                                                               \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tStore the character we read, and transition to the next\n"     \
	"\t\t\t *\tstate\n"                                                       \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tstate = newState;\n"                                               \
	"\n"                                                                      \
	"\t\t\tif (textSize >= textAlloc) {\n"                                    \
	"\t\t\t\tint32_t toFit = (textAlloc + 256) & ~255;\n"                     \
	"\t\t\t\tif (toFit < 256) toFit = 256;\n"                                 \
	"\t\t\t\tunsigned char *ptr = (unsigned char *)realloc(textBuffer, toFit);\n" \
	"\t\t\t\tif (ptr == NULL) {\n"                                            \
	"\t\t\t\t\tthrow std::bad_alloc();\n"                                     \
	"\t\t\t\t}\n"                                                             \
	"\n"                                                                      \
	"\t\t\t\ttextBuffer = ptr;\n"                                             \
	"\t\t\t\ttextAlloc = toFit;\n"                                            \
	"\t\t\t}\n"                                                               \
	"\t\t\ttextBuffer[textSize++] = (char)ch;\n"                              \
	"\n"                                                                      \
	"\t\t\t/*\n"                                                              \
	"\t\t\t *\tNote the current action if we have one\n"                      \
	"\t\t\t */\n"                                                             \
	"\n"                                                                      \
	"\t\t\tuint16_t newAction = StateActions[state];\n"                       \
	"\t\t\tif (newAction > MAXACTIONS) {\n"                                   \
	"\t\t\t\tnewAction = conditionalAction(newAction);\n"                     \
	"\t\t\t}\n"                                                               \
	"\t\t\tif (newAction != MAXACTIONS) {\n"                                  \
	"\t\t\t\taction = newAction;\n"                                           \
	"\t\t\t\tmark();\n"                                                       \
	"\t\t\t}\n"                                                               \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tIf no action is set, we simply abort after setting an internal\n" \
	"\t\t *\terror state. This should never happen in a well designed lexer\n" \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tif (action == MAXACTIONS) {\n"                                       \
	"\t\t\tfAbort = \"Illegal character sequence\";\n"                        \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tAction is set, so we rewind.\n"                                  \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\treset();\n"                                                          \
	"\t\tif (textSize == 0) {\n"                                              \
	"\t\t\tfAbort = \"No characters read in sequence\";\n"                    \
	"\t\t\treturn -1;\n"                                                      \
	"\t\t}\n"                                                                 \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tConvert text sequence into string\n"                             \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tfText = std::string((char *)textBuffer,textSize);\n"                 \
	"\t\tfValue = (void *)fText.c_str();\n"                                   \
	"\n"                                                                      \
	"\t\t/*\n"                                                                \
	"\t\t *\tExecute action\n"                                                \
	"\t\t */\n"                                                               \
	"\n"                                                                      \
	"\t\tswitch (action) {\n";

static const char *GSource5 =
	"\t\t\tdefault:\n"                                                        \
	"\t\t\t\tbreak;\n"                                                        \
	"\t\t}\n"                                                                 \
	"\t}\n"                                                                   \
	"}\n"                                                                     \
	"\n";


/************************************************************************/
/*																		*/
/*	State writer														*/
/*																		*/
/************************************************************************/

/*	OCLexCPPGenerator::WriteArray
 *
 *		Write an array. This simply writes the list of items to an array
 */

void OCLexCPPGenerator::WriteArray(FILE *f, uint32_t *list, size_t len)
{
	size_t i = 0;

	for (i = 0; i < len; ++i) {
		if (i) {
			fprintf(f,", ");
		}
		if ((i % 8) == 0) {
			if (i) fprintf(f,"\n");
			fprintf(f,"    ");
		}
		fprintf(f,"%3d",list[i]);
	}
	fprintf(f,"\n");
}

/*	OCLexCPPGenerator::WriteStates
 *
 *		Write the states
 */

void OCLexCPPGenerator::WriteStates(FILE *f)
{
	/*
	 *	Print the state sizes
	 */

	fprintf(f,"/************************************************************************/\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/*  Lex Transition State Tables                                         */\n");
	fprintf(f,"/*                                                                      */\n");
	fprintf(f,"/************************************************************************/\n");

	/*
	 *	Constants
	 */

	fprintf(f,"\n");
	fprintf(f,"/*\n");
	fprintf(f," *  Constants\n");
	fprintf(f," */\n\n");

	fprintf(f,"#define MAXSTATES       %lu\n",dfaStates.size());
	fprintf(f,"#define MAXCHARCLASS    %lu\n",charClasses.size());
	fprintf(f,"#define MAXACTIONS      %lu\n\n",codeRules.size());

	/*
	 *	Generate the character class list.
	 */

	uint32_t carray[256];
	size_t i,len = charClasses.size();
	for (i = 0; i < 256; ++i) carray[i] = (uint16_t)len;
	for (i = 0; i < len; ++i) {
		const OCCharSet &set = charClasses[i];
		for (int j = 0; j < 256; ++j) {
			if (set.TestCharacter((unsigned char)j)) {
				carray[j] = (uint32_t)i;
			}
		}
	}

	fprintf(f,"\n");
	fprintf(f,"//  Character classes used during parsing:\n");
	fprintf(f,"//\n");
	for (i = 0; i < len; ++i) {
		const OCCharSet &cset = charClasses[i];
		fprintf(f,"//  %zu: %s\n",i,cset.ToString().c_str());
	}
	fprintf(f,"\n");

	fprintf(f,"/*  CharClass\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps 8-bit character to character class\n");
	fprintf(f," */\n\n");
	fprintf(f,"static uint16_t CharClass[256] = {\n");
	WriteArray(f, carray, 256);
	fprintf(f,"};\n\n");

	/*
	 *	Generate state actions. This is a table which maps from a state
	 *	index to an action index. Note if this DFA state has no rule, we
	 *	land on MAXACTION. If the DFA has a conditional rule, we go to
	 *	an index greater than MAXACTION.
	 */

	fprintf(f,"/*  StateActions\n");
	fprintf(f," *\n");
	fprintf(f," *      Maps states to actions. MAXACTION if this is not a terminal\n");
	fprintf(f," */\n\n");

	size_t alen = codeRules.size();
	uint32_t swindex = (uint32_t)alen;
	len = dfaStates.size();
	uint32_t *scratch = (uint32_t *)malloc(len * sizeof(uint32_t));
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];

		if (state.endList.size() == 0) {
			scratch[i] = (uint32_t)alen;
		} else if ((state.endList.size() == 1) &&
				   (state.endList[0].startState.unconditional())) {
			scratch[i] = state.endList[0].endRule;
		} else {
			scratch[i] = ++swindex;
		}
	}

	fprintf(f,"static uint16_t StateActions[%zu] = {\n",len);
	WriteArray(f,scratch,len);
	fprintf(f,"};\n\n");
	free(scratch);

	/*
	 *	Generate the DFA state transitions
	 */

	size_t clen = charClasses.size();
	size_t tlen = len * clen;
	scratch = (uint32_t *)malloc(tlen * sizeof(uint32_t));

	size_t ptr = 0;
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];
		for (size_t j = 0; j < clen; ++j) {
			OCCharSet &cset = charClasses[j];

			/*
			 *	Find the transition which intersects
			 */

			uint32_t newState = (uint32_t)len;

			std::vector<OCLexDFATransition>::iterator t;
			for (t = state.list.begin(); t != state.list.end(); ++t) {
				if (t->set.Contains(cset)) {
					// This transition contains our cset. Set and move on
					newState = (uint32_t)t->state;
					break;
				}
			}

			scratch[ptr++] = newState;
		}
	}

	// New format
	fprintf(f,"/*  StateMachineIA, StateMachineJA, StateMachineA\n");
	fprintf(f," *\n");
	        // 01234567890123456789012345678901234567890123456789012345678901234567890123456789
	fprintf(f," *      Lex state machine in compressed sparce row storage format. We do this\n");
	fprintf(f," *  in order to compact the resulting sparse matrix state machine so we don't\n");
	fprintf(f," *  consume as much space. Decoding the new state becomes an O(log(N)) process\n");
	fprintf(f," *  on the input character class as we use a binary search on the JA array.\n");
	fprintf(f," *\n");
	fprintf(f," *      See the article below for more information:\n");
	fprintf(f," *\n");
	fprintf(f," *      https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR.2C_CRS_or_Yale_format.29\n");
	fprintf(f," */\n\n");

	OCCompressStates comp(clen,len,scratch,(uint32_t)len);

	fprintf(f,"static uint16_t StateMachineIA[%zu] = {\n",comp.iwidth);
	WriteArray(f,comp.ia,comp.iwidth);
	fprintf(f,"};\n\n");

	fprintf(f,"static uint16_t StateMachineJA[%zu] = {\n",comp.asize);
	WriteArray(f,comp.ja,comp.asize);
	fprintf(f,"};\n\n");

	fprintf(f,"static uint16_t StateMachineA[%zu] = {\n",comp.asize);
	WriteArray(f,comp.a,comp.asize);
	fprintf(f,"};\n\n");

	free(scratch);
}

/*	OCLexCPPGenerator::WriteActions
 *
 *		Write the actions state machine. This only writes the contents of
 *	the switch state, not the switch state itself.
 */

void OCLexCPPGenerator::WriteActions(FILE *f)
{
	size_t i,len = codeRules.size();
	for (i = 0; i < len; ++i) {
		fprintf(f,"            case %zu:\n",i);
		fprintf(f,"                %s\n",codeRules[i].code.c_str());
		fprintf(f,"                break;\n\n");
	}
}

/************************************************************************/
/*																		*/
/*	Write start states													*/
/*																		*/
/************************************************************************/

void OCLexCPPGenerator::WriteStarts(FILE *f, const char *className)
{
	uint32_t index = (uint32_t)codeRules.size();

	fprintf(f,"/*\n");
	fprintf(f," *  For conditional states this takes an end DFA state and\n");
	fprintf(f," *  determines the proper end rule given the current start\n");
	fprintf(f," *  conditionals.\n");
	fprintf(f," */\n\n");
	fprintf(f,"uint16_t %s::conditionalAction(uint16_t state)\n",className);
	fprintf(f,"{\n");
	fprintf(f,"    switch (state) {\n");
	fprintf(f,"        default:\n");
	fprintf(f,"            return MAXACTIONS;\n");

	uint32_t i,len;
	len = (uint32_t)dfaStates.size();
	for (i = 0; i < len; ++i) {
		OCLexDFAState &state = dfaStates[i];

		if ((state.endList.size() > 1) ||
			((state.endList.size() == 1) &&
				!state.endList[0].startState.unconditional())) {

			/*
			 *	This has at least one conditional rule or multiple rules.
			 *	Write them out
			 */

			bool atEnd = false;
			fprintf(f,"        case %d:\n",++index);

			uint32_t e,elen = (uint32_t)state.endList.size();
			for (e = 0; e < elen; ++e) {
				const OCLexDFAEnd &d = state.endList[e];

				if (d.startState.unconditional()) {
					fprintf(f,"            return %d;\n",d.endRule);
					atEnd = true;
					break;
				}

				bool flag = false;
				fprintf(f,"            if (");
				if (d.startState.startFlag()) {
					fprintf(f,"atSOL()");
					flag = true;
				}
				if (d.startState.endFlag()) {
					if (flag) {
						fprintf(f," && ");
					} else {
						flag = true;
					}
					fprintf(f,"atEOL()");
				}
				uint32_t m = d.startState.stateFlags(ruleStates);
				if (m) {
					if (flag) {
						fprintf(f," && ");
					}
					fprintf(f,"((%d & states) != 0)",m);
				}

				fprintf(f,") return %d;\n",d.endRule);
			}

			if (!atEnd) {
				fprintf(f,"            return MAXACTIONS;\n");
			}
		}
	}

	fprintf(f,"    }\n");
	fprintf(f,"}\n\n");
}

/************************************************************************/
/*																		*/
/*	Parser Definitions													*/
/*																		*/
/************************************************************************/

/*	OCLexCPPGenerator::WriteOCHeader
 *
 *		This generates the standard header file, using the specified
 *	class name.
 */

void OCLexCPPGenerator::WriteOCHeader(const char *className, const char *outName, FILE *f)
{
	fprintf(f,GHeader1,outName);

	// Header declarations
	fprintf(f,"%s\n\n",classHeader.c_str());

	fprintf(f,GHeader2,className,className,className,className);

	// Class global declarations
	fprintf(f,"%s\n\n",classGlobal.c_str());

	// Internal declarations
	fprintf(f,"%s\n",GHeader3);

	// Local declarations
	fprintf(f,"%s\n",classLocal.c_str());

	// Final
	fprintf(f,"%s\n",GHeader4);
}

/*	OCLexCPPGenerator::WriteOCFile
 *
 *		This generates the various tables and writes the Objective C
 *	lex file
 */

void OCLexCPPGenerator::WriteOCFile(const char *className, const char *outName, FILE *f)
{
	// Standard header
	fprintf(f,GSource1,outName,outName);

	// Declarations
	fprintf(f,"%s\n\n",declCode.c_str());

	// State declarations
	WriteStates(f);

	// Start class declaration
	fprintf(f,GSource2,className,className,className,className);

	fprintf(f,"%s\n",classInit.c_str());

	fprintf(f,GSource3,className,className,className,className,
					   className,className,className,className,
					   className,className,className,className,
					   className,className);

	// Post class declarations. We embed in our class
	fprintf(f,"%s\n\n",endCode.c_str());

	// Conditional class table
	WriteStarts(f,className);

	// Lexer engine
	fprintf(f,GSource4,className,className);

	// Action states
	WriteActions(f);

	// And the rest of the stuff
	fprintf(f,"%s",GSource5);
}
